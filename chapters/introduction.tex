\chapter{Introduction}

The aim of this thesis is to certify complexity bounds by construction:
to design programming and specification formalisms whose syntax
guarantees membership in a target complexity class, so that verifying a program's complexity
reduces to checking that it is syntactically correct.
The goal is not to make programming itself easier, but to make it easier for someone who receives
a program to trust that it is correct and runs within the claimed resource bounds.
Our conclusions are mostly \emph{negative}:
we explore several very promising fields of research and conclude that, in their current form,
they do not allow us to certify the complexity of programs at scale.
In~\autoref{sec:formalization} we present the main technical contribution of this work:
we explain how bounded arithmetic, combined with modern proof assistants, offers a viable
way to approach this goal.
Theories from bounded arithmetic generalize well to account for algorithms from higher and lower
complexity classes, in contrast to many systems from Implicit Computational Complexity
studied in~\autoref{chap:icc}, which are typically tailored to a single class.

\paragraph{Structure of this work}

In~\autoref{chap:foundations} we explore how different programming paradigms can help
us reach this goal.
We also consider the notion of complexity in other models of computation and whether it would make
sense to capture them instead of the complexity of Turing machine-like (imperative) models.

In~\autoref{chap:formalized-semantics} we examine the most obvious way of certifying complexity:
directly proving on a computer that a given C++ program operates in, say, time~\(\bigO(n^2)\).
Using an existing development in the Rocq proof assistant as a case study, we argue that this is not a viable solution
for certifying the complexity of realistic programs.

In~\autoref{chap:descriptive-complexity} we study logics that characterize computational complexity classes
by the complexity of formulas needed to describe their problems.
These characterizations are very well suited to decision problems, but less so to computing
general functions with output, as we usually do in programming.

In~\autoref{chap:reductions} we explore this idea further, examining how classes of decision and function
problems relate and whether this distinction matters for certifying complexity.
The answer is positive: it is not always trivial to reduce a general function problem to a decision problem.
In the same chapter, we examine the feasibility of capturing complexity classes by first fixing a complete
problem and then capturing the (weaker) programming language for reductions to that problem.
We can obtain \complexity{FL}, \complexity{FP}, and several circuit complexity classes this way, but at the price
of relying on characterizations of low circuit complexity classes that are not convenient to use either.
We defer a detailed treatment of circuit reductions and uniformity to an appendix and proceed to explore
direct characterizations of \complexity{FL} and \complexity{FP} in the next chapter.

In~\autoref{chap:icc} we study actual programming languages (more or less purely academic)
that capture complexity classes.
We conclude this chapter with a critique of these approaches:
they are fragmented (every complexity class would need a separate programming language), and
even for a fixed class, the theories are often able to \emph{solve every problem} in the class
but not \emph{express every algorithm} we naturally use to solve problems in that class.
Despite their relevance, we were not able to certify the complexity of existing algorithms
in these systems, and therefore we cannot use them as foundation for the kind of programming language we
are interested in.

In~\autoref{chap:bounded-arithmetic} we study how to extract computational content from proofs conducted
in bounded arithmetic, a field that studies mathematical theories that also capture computational complexity
classes.\footnote{Our work is available
at \url{https://github.com/ruplet/formalization-of-bounded-arithmetic}.}
This chapter collects our main technical results and explains why bounded arithmetic,
formalized in a proof assistant, appears to be a promising foundation for complexity-certified programming.
Part of this work was presented at AITP 2025 conference; an abstract of
our early developments is available at: \url{https://aitp-conference.org/2025/abstract/AITP_2025_paper_7.pdf}.\footnote{It was the
basis for the acceptance of our short talk; for the reviews, please see \url{https://github.com/ruplet/formalization-of-bounded-arithmetic/blob/main/presentation-AITP2025/aitp-reviews.md}.}
A significant part of the developments described in this chapter was conducted during the main author's 
visit to INRIA Paris, made possible by a scholarship from ZSM IDUB program.

% To illustrate the challenge we are addressing, consider the task of proving that binary multiplication belongs to LOGSPACE. 
% A common way to do it is to first argue that if we show a program that does it using only a finite number of variables, each of which of linear size (e.g. a pointer to the input), then the computation obviously uses only logarithmic amount of memory.
% However, this description is fragile: for instance, simply incrementing a variable in a `for` loop can exceed the LOGSPACE bound. In this work, we investigate more reliable characterizations.