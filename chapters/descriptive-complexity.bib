@article{GRADEL199235,
title = {Capturing complexity classes by fragments of second-order logic},
journal = {Theoretical Computer Science},
volume = {101},
number = {1},
pages = {35-57},
year = {1992},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(92)90149-A},
url = {https://www.sciencedirect.com/science/article/pii/030439759290149A},
author = {Erich Grädel},
abstract = {We investigate the expressive power of certain fragments of second-order logic on finite structures. The fragments are second-order Horn logic, second-order Krom logic as well as a symmetric and a deterministic version of the latter. It is shown that all these logics collapse to their existential fragments. In the presence of successor relation they provide characterizations of polynomial time, deterministic and nondeterministic logspace and of the complement of symmetric logspace. Without successor relation these logics still can express certain problems that are complete in the corresponding complexity classes, but on the other hand they are strictly weaker than previously known logics for these classes and fail to express some very simple properties.}
}

@book{Immerman1999-IMMDC,
	author = {Neil Immerman},
	title = {Descriptive Complexity},
	year = {1999},
      isbn = {978-1-4612-0539-5},
      url = {https://doi.org/10.1007/978-1-4612-0539-5},
	publisher = {Springer New York, NY},
      doi = {10.1007/978-1-4612-0539-5},
      pages = {268},
}

@book{Cook_Nguyen_2010,
title={Logical Foundations of Proof Complexity},
author={Cook, Stephen and Nguyen, Phuong},
year={2010},
place={Cambridge},
publisher={Cambridge University Press},
doi={10.1017/CBO9780511676277},
url       = {http://web.archive.org/web/20240713034207/https://www.karlin.mff.cuni.cz/~krajicek/cook-nguyen.pdf},
urldate   = {2025-09-03}
}

@article{IMMERMAN198686,
title = {Relational queries computable in polynomial time},
journal = {Information and Control},
volume = {68},
number = {1},
pages = {86-104},
year = {1986},
issn = {0019-9958},
doi = {https://doi.org/10.1016/S0019-9958(86)80029-8},
url = {https://www.sciencedirect.com/science/article/pii/S0019995886800298},
author = {Neil Immerman},
abstract = {We characterize the polynomial time computable queries as those expressible in relational calculus plus a least fixed point operator and a total ordering on the universe. We also show that even without the ordering one application of fixed point suffices to express any query expressible with several alternations of fixed point and negation. This proves that the fixed point query hierarchy suggested by Chandra and Harel collapses at the first fixed point level. It is also a general result showing that in finite model theory one application of fixed point suffices.}
}

@inproceedings{10.1145/800070.802186,
author = {Vardi, Moshe Y.},
title = {The complexity of relational query languages (Extended Abstract)},
year = {1982},
isbn = {0897910702},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800070.802186},
doi = {10.1145/800070.802186},
abstract = {Two complexity measures for query languages are proposed. Data complexity is the complexity of evaluating a query in the language as a function of the size of the database, and expression complexity is the complexity of evaluating a query in the language as a function of the size of the expression defining the query. We study the data and expression complexity of logical languages - relational calculus and its extensions by transitive closure, fixpoint and second order existential quantification - and algebraic languages - relational algebra and its extensions by bounded and unbounded looping. The pattern which will be shown is that the expression complexity of the investigated languages is one exponential higher then their data complexity, and for both types of complexity we show completeness in some complexity class.},
booktitle = {Proceedings of the Fourteenth Annual ACM Symposium on Theory of Computing},
pages = {137-146},
numpages = {10},
location = {San Francisco, California, USA},
series = {STOC '82}
}

@article{Cai1992,
  author    = {Jin-Yi Cai and Martin F{\"u}rer and Neil Immerman},
  title     = {An optimal lower bound on the number of variables for graph identification},
  journal   = {Combinatorica},
  year      = {1992},
  volume    = {12},
  number    = {4},
  pages     = {389--410},
  doi       = {10.1007/BF01305232},
  url       = {https://doi.org/10.1007/BF01305232},
  issn      = {1439-6912},
  abstract  = {In this paper we show that Ω(n) variables are needed for first-order logic with counting to identify graphs on n vertices. The k-variable language with counting is equivalent to the (k−1)-dimensional Weisfeiler-Lehman method. We thus settle a long-standing open problem. Previously it was an open question whether or not 4 variables suffice. Our lower bound remains true over a set of graphs of color class size 4. This contrasts sharply with the fact that 3 variables suffice to identify all graphs of color class size 3, and 2 variables suffice to identify almost all graphs. Our lower bound is optimal up to multiplication by a constant because n variables obviously suffice to identify graphs on n vertices.}
}

@article{10.1145/502807.502810,
author = {Dantsin, Evgeny and Eiter, Thomas and Gottlob, Georg and Voronkov, Andrei},
title = {Complexity and expressive power of logic programming},
year = {2001},
issue_date = {September 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {33},
number = {3},
issn = {0360-0300},
url = {http://web.archive.org/web/20240415065931/https://dai.fmph.uniba.sk/~sefranek/bak/dantsin97complexity.pdf},
doi = {10.1145/502807.502810},
abstract = {This article surveys various complexity and expressiveness results on different forms of logic programming. The main focus is on decidable forms of logic programming, in particular, propositional logic programming and datalog, but we also mention general logic programming with function symbols. Next to classical results on plain logic programming (pure Horn clause programs), more recent results on various important extensions of logic programming are surveyed. These include logic programming with different forms of negation, disjunctive logic programming, logic programming with equality, and constraint logic programming.},
journal = {ACM Comput. Surv.},
month = 9,
pages = {374-425},
numpages = {52},
keywords = {query languages, nonmonotonic logic, logic programming, expressive power, datalog, Complexity}
}

@misc{nesetril2021structuralpropertiesfirstordertransduction,
      title={Structural properties of the first-order transduction quasiorder}, 
      author={Jaroslav Nesetril and Patrice Ossona de Mendez and Sebastian Siebertz},
      year={2021},
      eprint={2010.02607},
      archivePrefix={arXiv},
      primaryClass={math.CO},
      url={https://arxiv.org/abs/2010.02607}, 
}

@article{COURCELLE199453,
title = {Monadic second-order definable graph transductions: a survey},
journal = {Theoretical Computer Science},
volume = {126},
number = {1},
pages = {53-75},
year = {1994},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(94)90268-2},
url = {https://www.sciencedirect.com/science/article/pii/0304397594902682},
author = {Bruno Courcelle},
abstract = {Formulas of monadic second-order logic can be used to specify graph transductions, i.e., multi-valued functions from graphs to graphs. We obtain in this way classes of graph transductions, called monadic second-order definable graph transductions (or, more simply, definable transductions) that are closed under composition and preserve the two known classes of context-free sets of graphs, namely the class of hyperedge replacement (HR) and the class of vertex replacement (VR) sets. These two classes can be characterized in terms of definable transductions and recognizable sets of finite trees, independently of the rewriting mechanisms used to define the HR and VR grammars. When restricted to words, the definable transductions are strictly more powerful than the rational transductions such that the image of every finite word is finite; they do not preserve context-free languages. We also describe the sets of discrete (edgeless) labelled graphs that are the images of HR and VR sets under definable transductions: this gives a version of Parikh's theorem (i.e., the characterization of the commutative images of context-free languages) which extends the classical one and applies to HR and VR sets of graphs}
}

@article{10.5555/2367430.2367437,
author = {Engelfriet, Joost and Hoogeboom, Hendrik Jan},
title = {Finitary Compositions of Two-way Finite-State Transductions},
year = {2007},
issue_date = {January 2007},
publisher = {IOS Press},
address = {NLD},
volume = {80},
number = {1-3},
issn = {0169-2968},
abstract = {The hierarchy of arbitrary compositions of two-way nondeterministic finite-state transductions collapses when restricted to finitary transductions, i.e., transductions that produce a finite set of outputs for each input. The hierarchy collapses to the class of nondeterministic MSO definable transductions, which is inside the second level of that hierarchy. It is decidable whether a composition of two-way nondeterministic finite-state transducers realizes a finitary transduction (i.e., is MSO definable).},
journal = {Fundam. Inf.},
month = 1,
pages = {111-123},
numpages = {13}
}

@InProceedings{10.1007/978-3-030-22996-2_19,
author="Moyen, Jean-Yves
and Simonsen, Jakob Grue",
editor="Manea, Florin
and Martin, Barnaby
and Paulusma, Dani{\"e}l
and Primiero, Giuseppe",
title="More Intensional Versions of Rice's Theorem",
booktitle="Computing with Foresight and Industry",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="217--229",
abstract="Classic results in computability theory concern extensional results: the behaviour of partial recursive functions rather than the programs computing them. We prove a generalisation of Rice's Theorem concerning equivalence classes of programs and show how it can be used to study intensional properties such as time and space complexity. While many results that follow from our general theorems can - and have - been proved by more involved, specialised methods, our results are sufficiently simple that little work is needed to apply them.",
isbn="978-3-030-22996-2"
}

@article{10.1145/319301.319317,
author = {Lamport, Leslie and Paulson, Lawrence C.},
title = {Should your specification language be typed},
year = {1999},
issue_date = {May 1999},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/319301.319317},
doi = {10.1145/319301.319317},
abstract = {Most specification languages have a type system. Type systems are hard to get right, and getting them wrong can lead to inconsistencies. Set theory can serve as the basis for a specification language without types. This possibility, which has been widely overlooked, offers many advantages. Untyped set theory is simple and is more flexible than any simple typed formalism. Polymorphism, overloading, and subtyping can make a type system more powerful, but at the cost of increased somplexity, and such refinements can never attain the flexibility of having no types at all. Typed formalisms have advantages, too, stemming from the power of mechanical type checking. While types serve little purpose in hand proofs, they do help with mechanized proofs. In the absence of verificaiton, type   checking can catch errors in specifications. It may be possible to have the best of both worlds by adding typing annotations to an untyped specification language.We consider only specification languages, not programming languages.},
journal = {ACM Trans. Program. Lang. Syst.},
month = may,
pages = {502-526},
numpages = {25},
keywords = {set theory, specification, types}
}

@misc{paulson2000settheoryverificationii,
      title={Set Theory for Verification: II. Induction and Recursion}, 
      author={Lawrence C. Paulson},
      year={2000},
      eprint={cs/9511102},
      archivePrefix={arXiv},
      primaryClass={cs.LO},
      url={https://arxiv.org/abs/cs/9511102}, 
}

@article{Bchi1960WeakSA,
  title={Weak Second-Order Arithmetic and Finite Automata},
  author={B{\"u}chi, J. Richard},
  journal={Mathematical Logic Quarterly},
  year={1960},
  volume={6},
  pages={66-92},
  url="http://web.archive.org/web/20251118183104/https://2024.sci-hub.st/173/04978b7adf46fde189eab42885cdc1d8/10.1002@malq.19600060105.pdf"
}



@article{8cb177c1-4df9-3823-9c81-47f75da88fff,
 ISSN = {00029947},
 URL = {http://web.archive.org/web/20250709105150/https://www.ams.org/journals/tran/1961-098-01/S0002-9947-1961-0139530-9/S0002-9947-1961-0139530-9.pdf},
 author = {Calvin C. Elgot},
 journal = {Transactions of the American Mathematical Society},
 number = {1},
 pages = {21--51},
 publisher = {American Mathematical Society},
 title = {Decision Problems of Finite Automata Design and Related Arithmetics},
 urldate = {2025-11-18},
 volume = {98},
 year = {1961}
}

@incollection{Fagin1974,
  author    = {Fagin, Ronald},
  title     = {Generalized First-Order Spectra and Polynomial-Time Recognizable Sets},
  booktitle = {Complexity of Computation},
  number    = {7},
  pages     = {43--73},
  year      = {1974},
  publisher = {American Mathematical Society},
  series    = {SIAM-AMS Proceedings}
}

% unofficial; this is unavailable......
@article{Trakhtenbrot1962,
  author       = {Trakhtenbrot, B. A.},
  title        = {Finite automata and monadic second order logic},
  journal      = {Siberian Mathematical Journal},
  volume       = {3},
  pages        = {101--131},
  year         = {1962},
  language     = {Russian},
  note         = {Russian original; English translation in: Amer. Math. Soc. Transl., Ser. 2, 59 (1966), 23--55}
}
