\section{Functions computable by Turing machines}\label{sec:preliminaries-turing-functions}
We introduce the notion of computing a general $\{0,1\}^{\ast} \to \{0,1\}^{\ast}$ function
early, as this is the primary interest of this thesis. Most of the literature in computational complexity
focuses solely
on computing Boolean functions which we introduce in~\autoref{sec:preliminaries-turing}.
To properly discuss this imbalance, we postpone introducing the \emph{functional}
complexity classes until~\autoref{chap:reductions}.


\begin{definition}[{\cites[Definition~1.3]{10.5555/1540612}[Definition~1.4]{DRAFT10.5555/1540612}}]
Let~\(f : \{0,1\}^{\ast} \to \{0,1\}^{\ast}\) and \(T : \mathbb{N} \to \mathbb{N}\) be functions, and let
\(M\) be a Turing machine.  We say that \(M\) \emph{computes} \(f\) if, for every input
        \(x \in \{0,1\}^{\ast}\), when \(M\) is started in its initial configuration
        on input \(x\), it eventually halts with the string \(f(x)\) written on its
        output tape.
\end{definition}


\section{Decisional Turing machine complexity classes}\label{sec:preliminaries-turing}

In this section we introduce standard complexity classes such as 
\(\complexity{L}\), \(\complexity{P}\) and \(\complexity{NP}\). It is important to note that these 
classes only contain \emph{decision} problems, i.e.\ only require
computing a function \(f : \{0,1\}^\ast \to \{0,1\}\). Complexity classes for general
functions will appear in.

\begin{notation}
    We say that a machine \emph{decides} a language \(L \subseteq \{0, 1\}^\ast\) iff it computes
    the function \(f_L: \{0, 1\}^\ast \rightarrow \{0, 1\}\), where \(f_L(x) = 1 \iff x \in L\).
\end{notation}

\begin{definition}[Time complexity~{\cites[Definition~1.19]{DRAFT10.5555/1540612}[Definition~1.12]{10.5555/1540612}}]\label{def:turing-dtime}
\hfill\\
Let~\(T~:~\mathbb{N} \to \mathbb{N}\) be a function.
We define \(\complexity{DTIME}(T(n))\) to be the class of all Boolean
functions that are computable by some deterministic
Turing machine running in at most \(c_1 \cdot T(n) + c_2\) steps on every input of
length \(n\), for some constants \(c_1, c_2 > 0\).
\end{definition}

\begin{definition}[Space complexity~{\cites[Definition~4.1]{DRAFT10.5555/1540612}[Definition~4.1]{10.5555/1540612}}]\label{def:turing-dspace}
\hfill\\
Let~\(S~:~\mathbb{N} \to \mathbb{N}\) be a function and let
\(L \subseteq \{0,1\}^{\ast}\) be a language.  
% \begin{enumerate}
%   \item 
  We say that \(L \in \complexity{SPACE}(S(n))\) iff there exist constants
        \(c_1, c_2 > 0\) and a deterministic Turing machine \(M\) deciding \(L\) such that,
        on every input of length \(n\), the machine \(M\) visits at most
        \(c_1 \cdot S(n) + c_2\) distinct cells on its read-write work tapes
        (the input tape is read-only and does not count toward the space
        bound).

%   \item Likewise, \(L \in \complexity{NSPACE}(S(n))\) if there exist a constant
%         \(c > 0\) and a nondeterministic Turing machine \(M\) deciding \(L\) such
%         that, for every input of length \(n\) and for every computation branch,
%         \(M\) uses no more than \(c \cdot S(n)\) nonblank work-tape cells.
% \end{enumerate}
\end{definition}


\begin{definition}[Logarithmic space~{\cites[Definition~4.5]{10.5555/1540612}[Definition~4.5]{DRAFT10.5555/1540612}}]\label{def:complexity-l}
\[
    \complexity{L} = \complexity{SPACE}(\log n).
\]
\end{definition}


\begin{definition}[Polynomial time~{\cites[Definition~1.13]{10.5555/1540612}[Definition~1.20]{DRAFT10.5555/1540612}}]\label{def:complexity-p}
\[
    \complexity{P} = \bigcup_{c \ge 1} \complexity{DTIME}(n^c).
\]
\end{definition}



\begin{definition}[The class \texorpdfstring{\complexity{NP}}{NP}{~\cites[Definition~2.1]{10.5555/1540612}[Definition~2.1]{DRAFT10.5555/1540612}}]\label{def:complexity-np}
\hfill\\
A~language~\(L \subseteq \{0,1\}^{\ast}\) belongs to \(\complexity{NP}\) if there exist
\begin{enumerate}
  \item a polynomial \(p : \mathbb{N} \to \mathbb{N}\) (bounding the length of a certificate); and
  \item a deterministic polynomial-time Turing machine \(M\)
        (called a \emph{verifier} for \(L\)),
\end{enumerate}
such that for every input string \(x \in \{0,1\}^{\ast}\),
\[
  x \in L
  \;\Longleftrightarrow\;
  \exists\,u \in \{0,1\}^{\,p(\len{x})} \ \text{with}\ M(x,u) = 1.
\]

Whenever \(x \in L\) and a string \(u \in \{0,1\}^{p(\len{x})}\) satisfies \(M(x,u)=1\),
the string \(u\) is called a \emph{certificate} (or \emph{witness}) for \(x\)
with respect to the language \(L\) and the verifier~\(M\).
\end{definition}
