\section{Classes of binary circuits}\label{sec:defs-preliminaries-circuits}


\begin{definition}
\todo[inline]{Define what is a circuit perhaps?}
\end{definition}

\begin{definition}[\NCipoly, \ACipoly, \TCipoly]\label{def:ac-nc-tc-poly}

Fix \(i \ge 0\).  
A language \(L \subseteq \{0,1\}^\ast\) belongs to one of the following
circuit classes if there exists a family of circuits
\(\{C_n\}_{n\in\mathbb{N}}\) such that \(C_n(x)=1\) iff \(x\in L\) and:

\begin{enumerate}
    \item\label{itm:circ-size} every circuit \(C_n\) has polynomially many gates w.r.t. \(n\);
    \item\label{itm:circ-depth} every circuit \(C_n\) has depth \(\bigO((\log n)^i)\);
    \item\label{itm:circ-nc} \(L \in \NCpoly{i}\) (Nick's class)  
          if each \(C_n\) uses only fan-in~2 \(\wedge\)-, fan-in~2 \(\vee\)-gates
          and fan-in~1 \(\neg\)-gates;

  \item\label{itm:circ-ac} \(L \in \ACpoly{i}\)  (Alternating circuits)
        if each \(C_n\) uses  
        unbounded fan-in \(\wedge\)-, unbounded fan-in \(\vee\)-gates and
        fan-in~1 \(\neg\)-gates;

  \item \label{itm:circ-tc}\(L \in \TCpoly{i}\)  (Threshold circuits)
        if each \(C_n\) uses unbounded fan-in \(\wedge\)-, unbounded fan-in \(\vee\)-gates,
        fan-in~1 \(\neg\)-gates and unbounded fan-in \emph{majority} gates
        (i.e.\ a gate that outputs 1 iff at least half of its inputs are one).
\end{enumerate}

Note that the condition \(C_n(x)=1\) iff \(x\in L\) requires the circuits
to have precisely one output node. We lift this requirement in~\autoref{def:aci-faci}.
% The full hierarchies are:
% \[
%   \complexity{AC}_{/poly}
%     = \bigcup_{i\ge 0} \ACpoly{i}, 
%   \qquad
%   \complexity{NC}_{/poly}
%     = \bigcup_{i\ge 0} \NCpoly{i}, 
%   \qquad
%   \complexity{TC}_{/poly}
%     = \bigcup_{i\ge 0} \TCpoly{i}.
% \]
\end{definition}


\begin{definition}[\FNCipoly, \FACipoly, \FTCipoly]\label{def:faci-poly}
A function \(F : \{0, 1\}^\ast \rightarrow \{0, 1\}^\ast\) belongs to
\FNCipoly (resp. \FACipoly, \FTCipoly) iff there exists a family of circuits
with multiple output nodes
\(
  \langle C_n \rangle_{n \in \mathbb{N}}
\)
such that whenever the input bits of \(C_n\) encode \(X \in \{0, 1\}^n\), the output bits
encode \(F(X)\); \(C_n\)
satisfies the size and depth
conditions~\ref{itm:circ-size},~\ref{itm:circ-depth} of~\autoref{def:ac-nc-tc-poly};
and additionally \(C_n\) satisfies the class condition~\ref{itm:circ-nc}
(resp.~\ref{itm:circ-ac},~\ref{itm:circ-tc}) of~\ref{def:ac-nc-tc-poly}.
\end{definition}

\begin{definition}[\compL-uniform circuit families]\label{def:logspace-uniformity}
      We say that a family of circuits \(\langle C_n \rangle_{n \in \mathbb{N}}\)
      is \compL-uniform if there exists a Turing machine operating in space \(\bigO(\log n)\),
      computing the function \(1^n \to C_n\) for some representation of \(C_n\).
\end{definition}

\begin{definition}[\NCi, \ACi, \TCi, \FNCi, \FACi, \FTCi]\label{def:aci-faci}
      A function \(F : \{0, 1\}^\ast \rightarrow \{0, 1\}^\ast\) belongs to
\FNCi (resp. \FACi, \FTCi) iff there exists a \compL-uniform family of circuits
satisfying the conditions from~\autoref{def:faci-poly}.
\end{definition}


% \subsection{Cicuit complexity classes}
% The complexity classes in this subsection are \emph{circuit complexity} classes,
% which means that the computation is done by \emph{boolean circuits}, which we will
% now introduce. Note that this is a different computational model to Turing machines, finite
% automata or lambda calculi, and thus comes with its own notion of complexity. The definitions
% in this subsection are based on~\cite[Definition 5.17]{Immerman1999-IMMDC}.



% \begin{definition}[Words accepted by a circuit]
% We say that a circuit \emph{accepts} a given binary word iff the value of its root is 1 with values of leaves
% set according to the input.
% \end{definition}

% \begin{definition}[Language decided by circuit family]
% We say that a family $\langle C_n \rangle_{n \in \mathbb{N}}$
% of boolean circuits decides a language $L$ iff for every $w \in \{0, 1\}^*$, $C_{|w|}$ accepts
% $w$ iff $w \in L$.
% \end{definition}

% \begin{definition}[\complexity{NC} circuits (Nick's class)]
% A boolean circuit is \emph{\complexity{NC}} iff the gates are only binary AND and OR gates.
% \end{definition}

% \begin{definition}[\complexity{AC} circuits (Alternating circuits)]
% A boolean circuit is \emph{\complexity{AC}} iff the gates are only unlimited fan-in AND and OR gates.
% It is a theorem that we can also allow unary NOT gates at leaves only.
% \end{definition}

% \begin{definition}[\complexity{TC} circuits (Threshold circuits)]
% A boolean circuit is \emph{\complexity{AC}} iff the gates are only unlimited fan-in Threshold(?) gates.
% It is a theorem that we can also allow unlimited fan-in AND and OR gates(?).
% \end{definition}

% \begin{definition}[\complexity{NC[t(n)]_{/poly}}, \complexity{AC[t(n)]_{/poly}}, \complexity{TC[t(n)]_{/poly}}]
% We define $\complexity{NC[t(n)]_{/poly}}$ to be the class of $\complexity{NC}$ circuits that:
% \begin{enumerate}
%    \item have polynomially-many internal nodes w.r.t. $n$, the number of leaves.
%    \item have depth $\bigO(t(n))$.
% \end{enumerate}
% Let $\complexityi{NC_{/poly}}{i} = \complexity{NC[(\log n)^i]_{/poly}}$. We define
% $\complexity{AC[t(n)]_{/poly}}, \complexity{TC[t(n)]_{/poly}}, \complexityi{AC_{/poly}}{i}, \complexityi{TC_{/poly}}{i}$ analogously.

% In particular, $\complexityi{NC_{/poly}}{0}$, $\complexityi{AC_{/poly}}{0}$, $\complexityi{TC_{/poly}}{0}$ are families of circuits with
% uniformly constant depth.

% For now we have not talked about how do we generate the consecutive circuits $C_n$.
% Later in~\autoref{sec:uniformity} we will restrict the family of (some standard) descriptions of the circuits
% to have to be \emph{computable efficiently} and then we will be able to drop the $_{/poly}$ suffix in our complexity classes.
% \end{definition}


% \section{\texorpdfstring{$\complexityi{NC}{i}_{/poly}$}{NC\string^ipoly}}

% \subsection{\complexityi{NC}{0}}
% For example, each output of an \complexityi{NC}{0} computable function can depend on only finitely many
% inputs. Thus, \complexityi{NC}{0} can't even compute an AND of all its inputs (in contrast, the unbounded
% fan-in AND is an \complexityi{AC}{0} function).
% \paragraph{TODO: Notes on $\complexityi{NC}{0}$.}
% TODO: Provide an introductory overview of the key references on $\complexityi{NC}{0}$ listed below.
% \begin{enumerate}
% \item TODO: Summarize the construction of one-way permutations in $\complexityi{NC}{0}$~\cite{10.1016/0020-01908790053-6}.
% \item TODO: Explain why all sets complete under $\complexityi{AC}{0}$ reductions are already complete under $\complexityi{NC}{0}$ reductions~\cite{10.1145/258533.258671,AGRAWAL1998127}.
% \item TODO: Describe Immerman's page~81 discussion of addition in $\complexityi{NC}{0}$ and MAJORITY in $\complexityi{NC}{1}$~\cite{Immerman1999-IMMDC}.
% \item TODO: Detail why addition and subtraction of binary numbers lies in $\complexityi{AC}{0}$~\cite{27676}.
% \end{enumerate}


% Given $x, y, z$: binary representations of natural numbers,
% it is decidable in uniform \complexityi{AC}{0} if $x + y = z$, but it is not decidable 
% in \complexityi{AC}{0} if $x * y = z$.

% \subsection{\complexityi{AC}{0}}
% \begin{enumerate}
% \item TODO: Summarize why addition is in $\complexityi{AC}{0}$~\cite{BussLectureNotes}.
% \item TODO: Explain the equivalence $\text{FO}[+, *] = \complexity{DLOGTIME}$-uniform $\complexityi{AC}{0}$ (see \url{https://complexityzoo.net/Complexity_Zoo:A#ac0}).
% \item TODO: Discuss the characterization of \complexity{DLOGTIME}-uniform $\complexityi{AC}{0}$ presented in~\cite{hella2023regularrepresentationsuniformtc0}.
% \item TODO: Review the definitions of $\complexityi{AC}{0}$, $\complexityi{TC}{0}$, FATC0, and FTC0 provided in~\cite{612309}.
% \end{enumerate}



% TODO: Check whether $\complexityi{TC}{i}$ is contained in $\complexityi{NC}{i + 1}$.
% \subsection{\complexityi{TC}{0}}
% \begin{enumerate}
% \item TODO: Confirm that multiplication is in $\complexityi{TC}{0}$~\cite{BussLectureNotes}, and locate the supporting details in~\cite{doi:10.1137/0213028}.
% \end{enumerate}
