

Dlaczego reprezentacja wejscia ma znaczenie:  
Boolean formula evaluation is only complete for \complexity{LOGSPACE} if input formulae are represented as graphs  
(e.g., by the list of all edges plus gate types). It was however shown in \[2\] that the problem is complete for  
\complexityi{NC}{1} under \complexityi{AC}{0}-reductions if input formulae are given by their natural string encoding.  
[https://arxiv.org/pdf/1212.6567](https://arxiv.org/pdf/1212.6567)

+ dlaczego reprezentacja ma znaczenie? bo jak to lista bitow, to struktura jest uporzadkowana. jak podajemy jakies pierdolone abstrakcyjne drzewo, to nie jest uporzadkowana i logika musi byc duzo mocniejsza zeby dalej rozwiazywac nasz problem\!


unary numbers
vs numbers in lambda calculus (exponential size????)
vs binary natural numbers (always one at beginning...)
vs binary strings

- what is the weakest representation of solvable Sudoku?

- Digression:
> conversion of MSO to NFA is non-elementary, but NFA to MSO is linear-time  
> what are the best data representations?  
> what about languages over the unary alphabet?  
> are there np-hard languages over the unary alphabet?  
> can the only data type in the language be {1^n: n in Nat}?  
> it seems natural that the data type for computers is { {0,1}^n: n in Nat},  
> but for set-theory based mathematics, it's Set = Empty | {Set},  
> where {} stands for... a set. So like a list, but with no order and no duplicates


\item TODO: Elaborate on how the algorithms for addition, subtraction of binary numbers in $\complexityi{NC}{0}/\complexityi{AC}{0}$ make use of the Chinese Remainder Representation or Fermat's Little Theorem.


NAJNOWSZY POMYSL:

1. Dlaczego powinniśmy rozważać słabe języki programowania? Bo mają lepsze własności. Mogą nam pozwolić na więcej automatyzacji.  
   1. Przykład: prosty kalkulator z dodawaniem, odejmowaniem, mnożeniem, dzieleniem. Łatwo sprawdzić czy pozwoli nam wykonać nasze obliczenia. Jeśli się to nam uda, to mamy gwarancję kiedy skończy obliczenia itp.  
   2. Przykład negatywny: silnik regex wyrażający NFA. nie mamy dobrej gwarancji ile zużyje zasobów\! może spowodować DDoS taki jak miał cloudflare  
   3. Przykład: język Haskell, który poprzez ograniczanie efektów ubocznych daje użytkownikowi “gwarancję” na to że program nie zrobi czegoś bardzo niespodziewanego  
   4. Mamy też theorems for free. Albo BCK?  
2.   
3. Chcemy napisać interpreter języka programowania.   
   1. W jakim najsłabszym języku możemy go napisać? To jest pytanie o to jaka “najładniejsza” (pod względem właściwości) teoria będzie w stanie zdefiniować funkcję wyrażającą interpreter, i do tego udowodnić jej poprawność względem specyfikacji i terminację  
4. Chcemy napisać funkcję GCD(x, y). W jakiej najsłabszej teorii możemy ją zdefiniować i udowodnić?  
   1. Bardzo ważne źródło: [https://projecteuclid.org/eBooks/perspectives-in-logic/Metamathematics-of-First-Order-Arithmetic/toc/pl/1235421926](https://projecteuclid.org/eBooks/perspectives-in-logic/Metamathematics-of-First-Order-Arithmetic/toc/pl/1235421926)   
   2. Również tutaj ważne: [https://link.springer.com/article/10.1007/BF01375521](https://link.springer.com/article/10.1007/BF01375521)  
   3. Albo w metalogice pokazujemy definicję w matematyce i realizujemy z niej program, albo dowodzimy poprawności danego programu\!
