\chapter{Reductions}\label{chap:reductions}
\todo[inline]{Here we notice that if we want a language for FP, and we have a FP-complete problem, and a language
for L-reductions (FL), then we have a language for FP!}


We introduce the definitions of complexity classes considered in this work.

In~\autoref{sec:decisional-complexity-classes} we introduce standard complexity classes such as 
\(\complexity{L}\), \(\complexity{P}\) and \(\complexity{NP}\). It is important to note that these 
definitions only talk about the complexity of computing \emph{Boolean} functions, i.e.\ functions 
\(f : \{0,1\}^\ast \to \{0,1\}\). These functions define \emph{decision} problems or \emph{languages}.

It is not at first obvious whether focusing solely on the complexity of Boolean functions is 
sufficient to reason about the general functions that we want to implement in a practical programming language. 
As we will see in~\autoref{sec:decisional-and-functional-complexity-classes}, the answer is negative.
In~\autoref{sec:functional-complexity-classes} we introduce the still standard, but much less talked about, 
\emph{functional} complexity classes,
that study general functions \(f : \{0,1\}^\ast \to \{0,1\}^\ast\) --- \emph{reductions}. The results
about these classes  transfer much better to our interests than results about the decisional complexity
classes. As we discuss  in~\autoref{chap:recursion-theory}, programming-language-like characterizations
of decisional complexity classes are more abundant and by far predate the characterizations of
functional complexity classes. It is the latter, however, that is viable for our purposes of
designing a programming language.


\begin{definition}[Time complexity]\label{def:turing-dtime}
Let \(T : \mathbb{N} \to \mathbb{N}\) be some function.  A language \(L\) belongs to \(\complexity{DTIME}(T(n))\) iff there exists a deterministic Turing machine that satisfies:
\begin{enumerate}[label= (\roman*), ref= (\roman*)]
    \item\label{itm:dtime} for some constant \(c > 0\) and every input \(w \in \{0,1\}^{n}\) it terminates within \(c \cdot T(n)\) steps;
    \item for every \(w \in L\) the machine outputs \(1\);
    \item for every \(w \notin L\) the machine outputs \(0\).
\end{enumerate}
We will say that a Turing machine belongs to \(\complexity{DTIME}(T(n))\) iff it satisfies~\ref{itm:dtime}.
\end{definition}

\begin{definition}[Space complexity]\label{def:turing-dspace}
Let \(T : \mathbb{N} \to \mathbb{N}\) be some function.  A language \(L\) belongs to \(\complexity{DSPACE}(T(n))\) iff there exists a deterministic Turing machine that satisfies:
\begin{enumerate}[label= (\roman*), ref= (\roman*)]
    \item\label{itm:dspace} for some constant \(c > 0\) and every input \(w \in \{0,1\}^{n}\) it halts while using at most \(c \cdot T(n)\) work-tape cells;
    \item for every \(w \in L\) the machine outputs \(1\);
    \item for every \(w \notin L\) the machine outputs \(0\).
\end{enumerate}
We will say that a Turing machine belongs to \(\complexity{DSPACE}(T(n))\) iff it satisfies~\ref{itm:dspace}.
\end{definition}





\section{Decisional complexity classes for Turing machines}\label{sec:decisional-complexity-classes}
We say that a machine decides a language \(L \subseteq \{0,1\}^\ast\) if it computes the 
characteristic function \(f_L : \{0,1\}^\ast \to \{0,1\}\), where \(f_L(x) = 1 \Leftrightarrow x \in L\).
Recall the definitions of complexity classes \(\complexity{DTIME}(T(n))\)~(\autoref{def:turing-dtime}) and \(\complexity{DSPACE}(T(n))\)~(\autoref{def:turing-dspace}).

\begin{definition}[\texorpdfstring{\complexity{L}}{L}]\label{def:complexity-l}
    \todo[inline]{Define...}
\end{definition}
Overview of problems complete for L:~\cite{COOK1987385}.

% \subsection{\complexity{P}}
\begin{definition}[\texorpdfstring{\complexity{P}}{P}]\label{def:complexity-p}
\todo[inline]{This definition should have the same style as NP, FP,FNP\@. This union-style is an outlier.}
\[
    \complexity{P} = \bigcup_{c \ge 1} \complexity{DTIME}(n^c).
\]
In other words, a language is in \(\complexity{P}\) if and only if it can be decided by a deterministic Turing machine that runs in polynomial time.
\end{definition}

\begin{definition}[\texorpdfstring{\complexity{NP}}{NP}]\label{def:complexity-np}
    \todo[inline]{Define...}
\end{definition}

% # Circuit Value Problem
% - For a given single-tape, polynomial-time Turing machine `M` and input `x`, in [@Kozen2006], there is an explicit construction of a boolean circuit over (0, 1, `and`, `or`, `not`) (with fan-in 2 for `and`, `or` and 1 for `not`), with one output node, such that its value is 1 if and only if machine `M` accepts input `x`. The construction is in LOGSPACE. So CVP is P-complete w.r.t. LOGSPACE-reductions.
% - This is a good example of a LOGSPACE-reduction, being a good benchmark for the LF programming language and for the circuit description language
% - The problem is that we can't generate tests for it; we have no database of Turing machines descriptions
A very good description of a problem complete for P:~\cite{Kozen2006}.


% \begin{definition}[Non-standard circuit view of \complexity{P}]
% One can also view \complexity{P} as a polynomial-time uniform family of Boolean circuits \(\{C_n\}_{n \in \mathbb{N}}\).
% Under this view, a language \(L\) is in \complexity{P} iff there exists such a family with:
% \begin{enumerate}[label=(\roman*)]
%     \item each \(C_n\) taking \(n\) input bits and producing one output bit;
%     \item for all \(x \in L\), \(C_{|x|}(x) = 1\);
%     \item for all \(x \notin L\), \(C_{|x|}(x) = 0\).
% \end{enumerate}
% We regard this circuit characterization as non-standard for the purposes of this text.
% \end{definition}

\section{Decisional and functional complexity classes}\label{sec:decisional-and-functional-complexity-classes}

\begin{example}
    Running time of any Turing machine computing the function \(x \rightarrow 2^x\) for input and output in binary,
    is exponential. At the same time, given an input \(x, y\), checking if \(y = 2^x\) is easily in polynomial time.
\end{example}
A very good discussion of the awkwardness of the definitions is present in~\cite{37813}.
A more thorough discussion of decision vs search is in~\cite{10.5555/889581}.
% Most problems that are considered in complexity theory ask, for a given input, whether it satisfies 
% some property, i.e.\ the return type of the function that solves the problem is a Boolean. Here we list 
% the definitions of some complexity classes that contain solely such decisional problems. These turn out 
% to be the most well-known complexity classes, but they are not the primary interest of this work. Our focus
% is on more general functions that can return a string, a pair of numbers, or a graph, and not just a Boolean value.
% After we introduce the decisional complexity classes in this section, we will later use them to define 
% functional complexity classes.


\section{Functional complexity classes}\label{sec:functional-complexity-classes}

\begin{definition}[FL]\label{def:fl}
    \todo[inline]{this are L-reductions}
% A binary relation \(P(x, y)\) is in \(\complexity{FP}\) iff there exists a polynomial-time Turing machine
% that, given an arbitrary input \(x\):
% \begin{enumerate}[label=(\roman*)]
%     \item outputs some \(y\) such that \(P(x, y)\) if any exists;
%     \item signals that no such \(y\) exists otherwise.
% \end{enumerate}
\end{definition}




\begin{definition}[FP]\label{def:fp}
    \todo[inline]{this are P-reductions}
A binary relation \(P(x, y)\) is in \(\complexity{FP}\) iff there exists a polynomial-time Turing machine
that, given an arbitrary input \(x\):
\begin{enumerate}[label=(\roman*)]
    \item outputs some \(y\) such that \(P(x, y)\) if any exists;
    \item signals that no such \(y\) exists otherwise.
\end{enumerate}



% Most importantly, FP is a different class - otherwise we can only check if IsZero(Bit_0) etc.
% Alternative definition of "P on unordered structures" defined in~\autoref{def:inv-P}.
% - example of a problem in P: Circuit value problem; given a circuit, the inputs and one gate in the circuit, calculate the output of that gate
% - example of a problem not in P: given two natural numbers in binary, calculate the sum of these numbers
% - the above problem requires us to output more than one bit. It is not a decision problem - it is a functional problem
% \section{\complexity{FP}}
% FP is formally defined as follows:
% A binary relation P ( x , y ) {\displaystyle P(x,y)} is in FP if and only if there is a deterministic polynomial time algorithm that, given x {\displaystyle x}, either finds some y {\displaystyle y} such that P ( x , y ) {\displaystyle P(x,y)} holds, or signals that no such y {\displaystyle y} exists
% transducers of polynomial growth are studied in~\cite{10.1145/3531130.3533326}, where also
% are given pebble, functinal, impearitve and logical models of computation.

\begin{remark}
Sometimes \(\complexity{FP}\) is defined to be the class of functions computable by polynomial-time Turing machines.
That style of definition makes it less convenient to compare \(\complexity{FP}\) with \(\complexity{FNP}\).
\end{remark}
\end{definition}

\subsection{FNP}

% \section{\complexity{FNP}}
% Equivalently, Q is FNP if and only
% if there is a non deterministic polynomial time algorithm that, given an arbitrary input x,
% can find some y such that (x, y) âˆˆ Q~\cite{bournez_et_al:LIPIcs.MFCS.2019.23}.


% \section{\complexity{FNP}}
% \begin{itemize}
% \item TODO: Extract the key points from the discussion at \url{https://cs.stackexchange.com/questions/71617/function-problems-and-fp-subseteq-fnp}.
% \item TODO: Summarize the insights from \url{https://cstheory.stackexchange.com/questions/37812/what-exactly-are-the-classes-fp-fnp-and-tfnp}.
% \item TODO: Cross-reference the definitions on \url{https://complexityzoo.net/Complexity_Zoo:F#fp}.
% \end{itemize}


% \section{\complexity{TFNP}}
% \label{sec:complexity-class-tfnp}


\begin{definition}[FNP]\label{def:fnp}
A binary relation \(P(x, y)\) is in \(\complexity{FNP}\) iff there exists a polynomial-time nondeterministic Turing machine
that, given some \(x\):
\begin{enumerate}[label=(\roman*)]
    \item outputs some \(y\) such that \(P(x, y)\) if any exists;
    \item signals that no such \(y\) exists otherwise.
\end{enumerate}
\begin{remark}
Equivalently~\cite[28.10~and~Theorem~28.9]{Rich2007Automata}, a binary relation \(P(x, y)\) is in \(\complexity{FNP}\) iff there exists a polynomial-time Turing machine
that, given some pair \((x, y)\), decides whether \(P(x, y)\).
\end{remark}
\end{definition}


\subsubsection{NP vs FNP: PRIMES and TFNP}\label{subsubsec:tfnp}
\begin{definition}[TFNP]\label{def:tfnp}
A binary relation \(P(x, y)\) is in \(\complexity{TFNP}\) (total \(\complexity{FNP}\)) iff it is
in \(\complexity{FNP}\) and for every \(x\) exists at least one \(y\) such that \(P(x, y)\).
\end{definition}

An interesting example of a problem in \(\complexity{TFNP}\) is \(\texttt{PIGEON}\) defined below,
for which we mathematically know that the answer exists, but finding it is not trivial.

\begin{definition}[\(\texttt{PIGEON}\)]\label{def:pigeon}
Given a binary string encoding a Boolean circuit \(C:\{0,1\}^n\!\to\!\{0,1\}^n\), return either
an input \(x\) such that \(C(x) = 0^n\), or two distinct inputs \(x \neq y\) such that \(C(x) = C(y)\).
\end{definition}

\begin{remark}\label{remark:}
    This class will be of our interest in~\autoref{subsec:vac0-php}, where we will discuss mathematical theories
    so weak that the pigeonhole principle is not their theorem. The intuition behind it is that
    the computational content of these theories is not strong enough to perform an exhaustive
    linear search of the whole domain.
\end{remark}


\subsubsection{NP vs FNP:\@ self-reducibility}
SAT problem is \emph{self-reducible}, i.e.\ we can solve the problem \(\texttt{FSAT}\) of finding a specific
satisfying assignment with polynomially many calls to the decision procedure \(\texttt{SAT}\). 
However, some total search problems such as discussed in~\ref{subsubsec:tfnp} are unlikely to
be self-reducible. This is discussed in slightly more detail in~\cite[Section 1.1]{10.5555/1104410}.

\subsection{Bibliographical remark}
The definition of \(\complexity{P}\) is in the style
of~\cites[Definition~1.13]{10.5555/1540612}[Definition~1.20]{DRAFT10.5555/1540612}.
The definition of reductions for search problems is in the style of~\cite{Goebel2011NashComplexity} and~\cite{Goldberg2021SearchTotal}.
The definition of \(\complexity{FP}\) and \(\complexity{FNP}\) is after~\cite[Section 28.10]{Rich2007Automata}.
\(\complexity{TFNP}\) was first introduced in~\cite{MEGIDDO1991317}.

\subsubsection{P vs FP}
These two classes are often identified due to similar properties.
The notion of completeness for both of them is practically the same despite being differently defined,
due to the robustness of \(\complexity{FP}\) computations under being repeated for every bit of the output.
Indeed, even in Stephen Cook's 1982 ACM Turing Award lecture~\cite[Section 6]{10.1145/358141.358144},
it is not clearly distinguished between
\(\complexity{P}\)-completeness and \(\complexity{FP}\)-completeness: the 3 proofs cited in this lecture
as proofs of \(\complexity{FP}\)-completeness of some functions \(f(x)\) only themselves prove the
\(\complexity{P}\)-completeness of problems of the form ``decide if \(i\)-th bit of the result \(f(x)\) is zero''.

The two classes, however, are not the same.
In~\cite[Theorem 4.1]{KRENTEL1988490}, it is proved that
\(\complexity{FP}^{\complexity{SAT}}[\bigO(\log{n})] = \complexity{FP}^{\complexity{SAT}}[n^{\bigO(1)}]\) implies \(\complexity{P}=\complexity{NP}\).
In turn, as noted in~\cite[discussion after Theorem 8]{doi:10.1142/9789812794499_0029}, the corresponding result for
\(\complexity{P}^\complexity{NP}\) versus \(\complexity{P}^\complexity{NP}[\log{n}]\) is not known,
and indeed fails relative to some oracles.


\subsection{Oracle complexity classes}
% Historical adnotation: this is whata i wanted from the beginning, oracle-oriented programming
% there is good evidence it should be possible

\section{Reductions}\label{sec:reductions}

\begin{definition}[Polynomial-time reductions for \complexity{FNP}]
    Let \(\texttt{HardProblem}\), \(\texttt{NewProblem}\) be search problems in \(complexity{FNP}\).
    We say that \(\texttt{HardProblem}\) (many-one) reduces to \(\texttt{NewProblem}\) if there exist
    \(f, g\) in \complexity{FP} such that:
    \[\texttt{NewProblem}(f(x), y) \implies \texttt{HardProblem}(x, g(y))\]

    For a given input \(x\) of \(\texttt{HardProblem}\), we can run \(\texttt{NewProblem}(f(x))\)
    to obtain some result \(y\), such that \(g(y)\) is the result of \(\texttt{HardProblem}(x)\).
\end{definition}


\subsection{Fine-grained reductions}\label{subsec:fine-grained-reductions}
% We will not realistically capture $\text{TIME}(\bigO(n))$ or anything of this kind,
% as the field of fine-grained complexity is relatively modern and little or none interesting
% characterizations of these classes have been found as of writing this work.
% \begin{itemize}
% \item TODO: Review Neil D. Jones's ``Constant Time Factors Do Matter'' for its discussion of NLIN-complete problems (\url{https://dl.acm.org/doi/pdf/10.1145/167088.167244}).
% \item TODO: Summarize the insights from Gurevich and Shelah's ``Nearly Linear Time'' concerning the definition of $\complexity{DTIME}(n)$ and nearly-linear-time-complete problems under QL reductions (\url{https://link.springer.com/content/pdf/10.1007/3-540-51237-3_10.pdf}).
% \end{itemize}
\todo[inline]{QL (quasilinear-time functions), NLT (robust complexity class for 
    \( \complexity{DTIME} (n (\log{n})^{\bigO(1)}) \) 
    on RAM machines~\cite{10.1007/3-540-51237-3_10})
}


\section{Equal classes}
% L = SL

% classe not equal, but reductions are equal sometimes!


we will have stronger, but in arithmetic



% % - Dla pewnych klas L, FL = L + AC0 redukcje (Cook). Dla innych klas tez?
% % - mozemy czy nie wielomianowo duzo razy odpalic "czy i-ty bit wyniku to 0? czy 1?" dla grafu funkcji?




% \section{\complexity{LOGSPACE} reduction}
% \begin{itemize}
% \item TODO: reductions for \complexity{L}: first-order reductions (see~\cite[Section~5.1]{Immerman1999-IMMDC}).
% \item TODO: Revisit why USTCONN is complete for \complexity{L}.
% \item TODO: Example programming language characterizing \complexity{L}: finite number of variables each bounded by $n$.
% \item TODO: Explore the alternative characterization using a finite number of input pointers, relating it to multi-head two-way automata~\cite{423885},~\cite{10.1007/BF00289513}.
% \end{itemize}

% \section{\complexity{P} reduction}
% TODO: Outline the notion of \complexity{P}-reductions to be used later in this chapter.

% \section{Complete problems}
% \label{sec:complete-problems}
% TODO: (this is Cook, Nguyen somewher) Verify that for every class $C \in \{\complexityi{AC}{0}, \complexity{L}, \complexity{P}\}$ there exists a problem $F$ that is $C$-complete under $\complexityi{AC}{0}$ reductions.
% TODO: This means $\complexityi{AC}{0}$ reductions coincide with the class of $\complexityi{FAC}{0}$ functions.


% \section{Which class we will focus on?}
% \label{sec:classes-of-interest}
% For chapters about ICC we will focus on \complexity{L} and \complexity{P}, as these are the most abundant reductions,
% and other classes might have problems like in the below subsections.
% Later, in the chapter about bounded arithmetic we will find that we actually want to care
% about characterization of $\complexityi{AC}{0}$-reductions.


\subsection{Semantic and syntactic complexity classes}
in~\cite{DBLP:conf/innovations/GoldbergP18}, the authors define a new complexity class \(\complexity{PTFNP \subseteq \complexity{TFNP}}\), for which
they prove the existence of a complete problem, and call this class ``syntactic''.
% TODO: Investigate which classes can realistically be characterized, likely excluding \complexity{BPP} and permutation-invariant \complexity{PTIME} (see \url{https://mathoverflow.net/questions/35236/is-there-a-syntactic-characterization-for-bpp-bqp-or-qma}).
% \begin{itemize}

% \item TODO: Extract key questions and scenarios from Anuj Dawar's ``On Syntactic and Semantic Complexity Classes'' (Spitalfields Day, Isaac Newton Institute, 9 January 2012), including the ``Two Possible Worlds'' discussion (\url{http://web.archive.org/web/20250428195619/https://www.frontiersinai.com/turingfiles/January/Dawar,%20A.pdf}).

% % ## Classes (conjectured) impossible to be captured syntactically
% % Some of the studied complexity classes remain notoriously difficult to be characterized implicitly. 
% % The classes for which a characterization exists are called 'syntactic' complexity classes, as opposed to 'semantic'
% % complexity classes, for which such characterization is conjectured to not exist.

% % - BPP  
% %     a characterization of which was however studied in [@lago2012higherordercharacterizationprobabilisticpolynomial].
% %     Despite that, PP has been characterized implicitly by Dal Lago in 2021: $\text{PP}$ [@dallago_et_al:LIPIcs.MFCS.2021.35].

% % - permutation-invariant PTIME
% %     The class `inv-P` of graph permutation-invariant problems decidable in polynomial time, is conjectured
% %     to not be characterizable this way. This is a restatement of the problem of finding a "logic capturing PTIME on unordered structures".
% %     A good discussion of this problem is present in Anuj Dawar's presentation from 2012: [@dawar2012syntactic].


% \end{itemize}

% \subsection{Related works on specifically the \complexity{FL} class}
% Early function algebras for \complexity{FL} appeared in~\cite{10.1145/1008293.1008295} and~\cite{lind1974logspace},
% but these were explicit characterizations.
% In~\cite{10.1007/BF01201998} it was shown how to readily use their concept
% to characterize functions from \complexity{FL} with ``small output'', but this characterization
% relied on using unary representation of natural numbers on input, which is more of a 
% hack than a true characterization of this class.
% In~\cite{murawski2000can}, with further refinements in~\cite{MURAWSKI2004197},
% \(BC^{-}\) was introduced, an algebra that was contained in \complexity{FL},
% but was not known (and unlikely) to be \complexity{FL}-complete.
% In~\cite{Neergaard04} this was improved to the result that \(BC_\varepsilon^{-} = \complexity{FL}\),
% with a short discussion that using course-of-value affine recursion instead of predicative affine recursion
% seem to be the reason behind \(BC_\varepsilon^{-}\) being FL-complete, and \(BC^{-}\) being probably not.

% In~\cite{4276584}, Stratified Bounded Affine Logic is introduced to capture \complexity{FL} computation.
% In~\cite{10.1007/978-3-662-46678-0_27}, an interesting approach using coinduction is utilized to capture \complexity{FL}.

% In~\cite{hofmann2006logspace} a good overview of languages for \complexity{FL} is presented,
% and in~\cite{schoepp2006spaceefficiency}, the history of \complexity{FL} characterizations is traced.
