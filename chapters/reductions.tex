\chapter{Reductions}\label{chap:reductions}
We introduce the definitions of complexity classes considered in this work.

In~\autoref{sec:decisional-complexity-classes} we introduce standard complexity classes such as 
\(\complexity{L}\), \(\complexity{P}\) and \(\complexity{NP}\). It is important to note that these 
definitions only talk about the complexity of computing \emph{Boolean} functions, i.e.\ functions 
\(f : \{0,1\}^\ast \to \{0,1\}\). These functions define \emph{decision} problems or \emph{languages}.

It is not at first obvious whether focusing solely on the complexity of Boolean functions is 
sufficient to reason about the general functions that we want to implement in a practical programming language. 
As we will see in~\autoref{sec:decisional-and-functional-complexity-classes}, the answer is negative.
In~\autoref{sec:functional-complexity-classes} we introduce the still standard, but much less talked about, 
\emph{functional} complexity classes,
that study general functions \(f : \{0,1\}^\ast \to \{0,1\}^\ast\) --- \emph{reductions}. The results
about these classes  transfer much better to our interests than results about the decisional complexity
classes. As we discuss  in~\autoref{chap:recursion-theory}, programming-language-like characterizations
of decisional complexity classes are more abundant and by far predate the characterizations of
functional complexity classes. It is the latter, however, that is viable for our purposes of
designing a programming language.

\section{Decisional complexity classes for circuits}
\begin{definition}[\texorpdfstring{\(\complexity{AC}^i\)}{ACi}]\label{def:complexity-aci}
    \todo[inline]{Define...}
\end{definition}


\section{Decisional complexity classes for Turing machines}\label{sec:decisional-complexity-classes}
We say that a machine decides a language \(L \subseteq \{0,1\}^\ast\) if it computes the 
characteristic function \(f_L : \{0,1\}^\ast \to \{0,1\}\), where \(f_L(x) = 1 \Leftrightarrow x \in L\).
Recall the definitions of complexity classes \(\complexity{DTIME}(T(n))\)~(\autoref{def:turing-dtime}) and \(\complexity{DSPACE}(T(n))\)~(\autoref{def:turing-dspace}).

\begin{definition}[\texorpdfstring{\complexity{L}}{L}]\label{def:complexity-l}
    \todo[inline]{Define...}
\end{definition}

% \subsection{\complexity{P}}
\begin{definition}[\texorpdfstring{\complexity{P}}{P}]\label{def:complexity-p}
\todo[inline]{This definition should have the same style as NP, FP,FNP\@. This union-style is an outlier.}
\[
    \complexity{P} = \bigcup_{c \ge 1} \complexity{DTIME}(n^c).
\]
In other words, a language is in \(\complexity{P}\) if and only if it can be decided by a deterministic Turing machine that runs in polynomial time.
\end{definition}

\begin{definition}[\texorpdfstring{\complexity{NP}}{NP}]\label{def:complexity-np}
    \todo[inline]{Define...}
\end{definition}

% \begin{definition}[Non-standard circuit view of \complexity{P}]
% One can also view \complexity{P} as a polynomial-time uniform family of Boolean circuits \(\{C_n\}_{n \in \mathbb{N}}\).
% Under this view, a language \(L\) is in \complexity{P} iff there exists such a family with:
% \begin{enumerate}[label=(\roman*)]
%     \item each \(C_n\) taking \(n\) input bits and producing one output bit;
%     \item for all \(x \in L\), \(C_{|x|}(x) = 1\);
%     \item for all \(x \notin L\), \(C_{|x|}(x) = 0\).
% \end{enumerate}
% We regard this circuit characterization as non-standard for the purposes of this text.
% \end{definition}

\section{Decisional and functional complexity classes}\label{sec:decisional-and-functional-complexity-classes}
% Most problems that are considered in complexity theory ask, for a given input, whether it satisfies 
% some property, i.e.\ the return type of the function that solves the problem is a Boolean. Here we list 
% the definitions of some complexity classes that contain solely such decisional problems. These turn out 
% to be the most well-known complexity classes, but they are not the primary interest of this work. Our focus
% is on more general functions that can return a string, a pair of numbers, or a graph, and not just a Boolean value.
% After we introduce the decisional complexity classes in this section, we will later use them to define 
% functional complexity classes.


\section{Functional complexity classes}\label{sec:functional-complexity-classes}

\begin{definition}[FL]\label{def:fl}
    \todo[inline]{this are L-reductions}
% A binary relation \(P(x, y)\) is in \(\complexity{FP}\) iff there exists a polynomial-time Turing machine
% that, given an arbitrary input \(x\):
% \begin{enumerate}[label=(\roman*)]
%     \item outputs some \(y\) such that \(P(x, y)\) if any exists;
%     \item signals that no such \(y\) exists otherwise.
% \end{enumerate}
\end{definition}

\begin{definition}[FP]\label{def:fp}
    \todo[inline]{this are P-reductions}
A binary relation \(P(x, y)\) is in \(\complexity{FP}\) iff there exists a polynomial-time Turing machine
that, given an arbitrary input \(x\):
\begin{enumerate}[label=(\roman*)]
    \item outputs some \(y\) such that \(P(x, y)\) if any exists;
    \item signals that no such \(y\) exists otherwise.
\end{enumerate}

\begin{remark}
Sometimes \(\complexity{FP}\) is defined to be the class of functions computable by polynomial-time Turing machines.
That style of definition makes it less convenient to compare \(\complexity{FP}\) with \(\complexity{FNP}\).
\end{remark}
\end{definition}

\subsection{FNP}
\begin{definition}[FNP]\label{def:fnp}
A binary relation \(P(x, y)\) is in \(\complexity{FNP}\) iff there exists a polynomial-time nondeterministic Turing machine
that, given some \(x\):
\begin{enumerate}[label=(\roman*)]
    \item outputs some \(y\) such that \(P(x, y)\) if any exists;
    \item signals that no such \(y\) exists otherwise.
\end{enumerate}
\begin{remark}
Equivalently~\cite[28.10~and~Theorem~28.9]{Rich2007Automata}, a binary relation \(P(x, y)\) is in \(\complexity{FNP}\) iff there exists a polynomial-time Turing machine
that, given some pair \((x, y)\), decides whether \(P(x, y)\).
\end{remark}
\end{definition}


\subsubsection{NP vs FNP: PRIMES and TFNP}\label{subsubsec:tfnp}
\begin{definition}[TFNP]\label{def:tfnp}
A binary relation \(P(x, y)\) is in \(\complexity{TFNP}\) (total \(\complexity{FNP}\)) iff it is
in \(\complexity{FNP}\) and for every \(x\) exists at least one \(y\) such that \(P(x, y)\).
\end{definition}

An interesting example of a problem in \(\complexity{TFNP}\) is \(\texttt{PIGEON}\) defined below,
for which we mathematically know that the answer exists, but finding it is not trivial.

\begin{definition}[\(\texttt{PIGEON}\)]\label{def:pigeon}
Given a binary string encoding a Boolean circuit \(C:\{0,1\}^n\!\to\!\{0,1\}^n\), return either
an input \(x\) such that \(C(x) = 0^n\), or two distinct inputs \(x \neq y\) such that \(C(x) = C(y)\).
\end{definition}

\begin{remark}\label{remark:}
    This class will be of our interest in~\autoref{subsec:vac0-php}, where we will discuss mathematical theories
    so weak that the pigeonhole principle is not their theorem. The intuition behind it is that
    the computational content of these theories is not strong enough to perform an exhaustive
    linear search of the whole domain.
\end{remark}


\subsubsection{NP vs FNP:\@ self-reducibility}
SAT problem is \emph{self-reducible}, i.e.\ we can solve the problem \(\texttt{FSAT}\) of finding a specific
satisfying assignment with polynomially many calls to the decision procedure \(\texttt{SAT}\). 
However, some total search problems such as discussed in~\ref{subsubsec:tfnp} are unlikely to
be self-reducible. This is discussed in slightly more detail in~\cite[Section 1.1]{10.5555/1104410}.

\subsection{\texorpdfstring{\(\complexity{FAC}^i\)}{FACi}}
\begin{definition}\label{def:faci}
    \todo[inline]{Define fac}
\end{definition}



\subsection{Bibliographical remark}
The definition of \(\complexity{P}\) is in the style
of~\cites[Definition~1.13]{10.5555/1540612}[Definition~1.20]{DRAFT10.5555/1540612}.
The definition of reductions for search problems is in the style of~\cite{Goebel2011NashComplexity} and~\cite{Goldberg2021SearchTotal}.
The definition of \(\complexity{FP}\) and \(\complexity{FNP}\) is after~\cite[Section 28.10]{Rich2007Automata}.
\(\complexity{TFNP}\) was first introduced in~\cite{MEGIDDO1991317}.
The definitions of decisional circuit classes are from~\cite{10.5555/520668}.

\subsubsection{P vs FP}
These two classes are often identified due to similar properties.
The notion of completeness for both of them is practically the same despite being differently defined,
due to the robustness of \(\complexity{FP}\) computations under being repeated for every bit of the output.
Indeed, even in Stephen Cook's 1982 ACM Turing Award lecture~\cite[Section 6]{10.1145/358141.358144},
it is not clearly distinguished between
\(\complexity{P}\)-completeness and \(\complexity{FP}\)-completeness: the 3 proofs cited in this lecture
as proofs of \(\complexity{FP}\)-completeness of some functions \(f(x)\) only themselves prove the
\(\complexity{P}\)-completeness of problems of the form ``decide if \(i\)-th bit of the result \(f(x)\) is zero''.

The two classes, however, are not the same.
In~\cite[Theorem 4.1]{KRENTEL1988490}, it is proved that
\(\complexity{FP}^{\complexity{SAT}}[\bigO(\log{n})] = \complexity{FP}^{\complexity{SAT}}[n^{\bigO(1)}]\) implies \(\complexity{P}=\complexity{NP}\).
In turn, as noted in~\cite[discussion after Theorem 8]{doi:10.1142/9789812794499_0029}, the corresponding result for
\(\complexity{P}^\complexity{NP}\) versus \(\complexity{P}^\complexity{NP}[\log{n}]\) is not known,
and indeed fails relative to some oracles.

% # About a language for FNP {.allowframebreaks}
% - NP is characterized by existential second-order logic
% - what about functional NP?
% - FSAT (provide a witness for satisfiability) can be PTIME-reduced to SAT:
% - ,,is phi with x_0=0 satisfiable? if so, x_0=0 ...''
% - can every NP search problem be reduced to a corresponding NP decision problem?
% - major open problem. All NP-complete search problems reduce to their decision problems (source: complexity zoo: FNP)
% - e.g. checking if number is prime is ptime, but factorizing is conjectured to be NP-intermediate [@kabanets]



\section{Reductions}\label{sec:reductions}

\begin{definition}[Polynomial-time reductions for \complexity{FNP}]
    Let \(\texttt{HardProblem}\), \(\texttt{NewProblem}\) be search problems in \(complexity{FNP}\).
    We say that \(\texttt{HardProblem}\) (many-one) reduces to \(\texttt{NewProblem}\) if there exist
    \(f, g\) in \complexity{FP} such that:
    \[\texttt{NewProblem}(f(x), y) \implies \texttt{HardProblem}(x, g(y))\]

    For a given input \(x\) of \(\texttt{HardProblem}\), we can run \(\texttt{NewProblem}(f(x))\)
    to obtain some result \(y\), such that \(g(y)\) is the result of \(\texttt{HardProblem}(x)\).
\end{definition}


\subsection{Fine-grained reductions}\label{subsec:fine-grained-reductions}

\todo[inline]{QL (quasilinear-time functions), NLT (robust complexity class for 
    \( \complexity{DTIME} (n (\log{n})^{\bigO(1)}) \) 
    on RAM machines~\cite{10.1007/3-540-51237-3_10})
}


\section{Uniformity}\label{sec:uniformity}

\subsection{\complexity{DLOGTIME}-uniformity}\label{subsec:dlogtime-uniformity}
\begin{itemize}
\item TODO:\@ Work out the example of a \complexity{DLOGTIME} reduction showing that tree isomorphism for string-represented trees is $\complexityi{NC}{1}$-complete~\cite{694595}.
\end{itemize}

% \section{Equal classes}
% # References {.allowframebreaks}
% 1. REG = dspace(o(log n))
% https://cs.stackexchange.com/questions/126451/textdspaceo1-textreg-proof/142760#142760
% https://cs.stackexchange.com/questions/57937/are-all-functions-with-constant-space-complexity-in-reg?noredirect=1&lq=1
% https://cs.stackexchange.com/questions/126451/textdspaceo1-textreg-proof?noredirect=1&lq=1
% % AUTHOR = {Shaull (https://cs.stackexchange.com/users/6890/shaull)},
% @MISC {142760,
%     TITLE = {$\text{DSPACE}(O(1))=\text{REG}$ Proof?},
%     author={shaull},
%     year={2021},
%     HOWPUBLISHED = {Computer Science Stack Exchange},
%     NOTE = {URL:https://cs.stackexchange.com/q/142760 (version: 2021-07-28)},
%     EPRINT = {https://cs.stackexchange.com/q/142760},
%     URL = {https://cs.stackexchange.com/q/142760}
% }


% 2. FAC0 is enough for reductions:
% Cook, Nguyen shows that FAC0 is enough for reductions

% We will not realistically capture $\text{TIME}(\bigO(n))$ or anything of this kind,
% as the field of fine-grained complexity is relatively modern and little or none interesting
% characterizations of these classes have been found as of writing this work.
% \begin{itemize}
% \item TODO: Review Neil D. Jones's ``Constant Time Factors Do Matter'' for its discussion of NLIN-complete problems (\url{https://dl.acm.org/doi/pdf/10.1145/167088.167244}).
% \item TODO: Summarize the insights from Gurevich and Shelah's ``Nearly Linear Time'' concerning the definition of $\complexity{DTIME}(n)$ and nearly-linear-time-complete problems under QL reductions (\url{https://link.springer.com/content/pdf/10.1007/3-540-51237-3_10.pdf}).
% \end{itemize}


% % TODO: czemu nie moge zrobic po prostu jezyka np. dla problemu P-zupelnego, albo 3SUM-zupelnego,
% % i do tego jakies proste redukcje, np. L-redukcje? jakie redukcje sa potrzebne dla jakiej klasy?
% % kiedy wystarczy mi oracle dla problemu decyzyjnego + redukcje?
% % - Dla pewnych klas L, FL = L + AC0 redukcje (Cook). Dla innych klas tez?
% % - mozemy czy nie wielomianowo duzo razy odpalic "czy i-ty bit wyniku to 0? czy 1?" dla grafu funkcji?




% Most importantly, FP is a different class - otherwise we can only check if IsZero(Bit_0) etc.
% Alternative definition of "P on unordered structures" defined in~\autoref{def:inv-P}.

% \section{\complexity{FP}}
% FP is formally defined as follows:
% A binary relation P ( x , y ) {\displaystyle P(x,y)} is in FP if and only if there is a deterministic polynomial time algorithm that, given x {\displaystyle x}, either finds some y {\displaystyle y} such that P ( x , y ) {\displaystyle P(x,y)} holds, or signals that no such y {\displaystyle y} exists
% transducers of polynomial growth are studied in~\cite{10.1145/3531130.3533326}, where also
% are given pebble, functinal, impearitve and logical models of computation.


% \section{\complexity{FNP}}
% Equivalently, Q is FNP if and only
% if there is a non deterministic polynomial time algorithm that, given an arbitrary input x,
% can find some y such that (x, y) âˆˆ Q~\cite{bournez_et_al:LIPIcs.MFCS.2019.23}.




% - example of a problem in P: Circuit value problem; given a circuit, the inputs and one gate in the circuit, calculate the output of that gate
% - example of a problem not in P: given two natural numbers in binary, calculate the sum of these numbers
% - the above problem requires us to output more than one bit. It is not a decision problem - it is a functional problem




% \subsection{Cicuit complexity classes}
% The complexity classes in this subsection are \emph{circuit complexity} classes,
% which means that the computation is done by \emph{boolean circuits}, which we will
% now introduce. Note that this is a different computational model to Turing machines, finite
% automata or lambda calculi, and thus comes with its own notion of complexity. The definitions
% in this subsection are based on~\cite[Definition 5.17]{Immerman1999-IMMDC}.

% \begin{definition}[Boolean circuits]
% A \emph{boolean circuit} is a finite directed, acyclic graph. The leaf nodes (of indegree zero)
% represent the input, which here is always a finite binary string. The internal nodes
% represent logical gates such as AND, OR and NOT gates, in that we say that the value
% of an internal AND node is 1 if the values of all of its children is 1 etc.
% For decisional problems we require the circuit to be rooted. A rigorous definition is discussed in~\cite[Definition 2.27]{Immerman1999-IMMDC}.
% \end{definition}

% \begin{definition}[Words accepted by a circuit]
% We say that a circuit \emph{accepts} a given binary word iff the value of its root is 1 with values of leaves
% set according to the input.
% \end{definition}

% \begin{definition}[Language decided by circuit family]
% We say that a family $\langle C_n \rangle_{n \in \mathbb{N}}$
% of boolean circuits decides a language $L$ iff for every $w \in \{0, 1\}^*$, $C_{|w|}$ accepts
% $w$ iff $w \in L$.
% \end{definition}

% \begin{definition}[\complexity{NC} circuits (Nick's class)]
% A boolean circuit is \emph{\complexity{NC}} iff the gates are only binary AND and OR gates.
% \end{definition}

% \begin{definition}[\complexity{AC} circuits (Alternating circuits)]
% A boolean circuit is \emph{\complexity{AC}} iff the gates are only unlimited fan-in AND and OR gates.
% It is a theorem that we can also allow unary NOT gates at leaves only.
% \end{definition}

% \begin{definition}[\complexity{TC} circuits (Threshold circuits)]
% A boolean circuit is \emph{\complexity{AC}} iff the gates are only unlimited fan-in Threshold(?) gates.
% It is a theorem that we can also allow unlimited fan-in AND and OR gates(?).
% \end{definition}

% \begin{definition}[\complexity{NC[t(n)]_{/poly}}, \complexity{AC[t(n)]_{/poly}}, \complexity{TC[t(n)]_{/poly}}]
% We define $\complexity{NC[t(n)]_{/poly}}$ to be the class of $\complexity{NC}$ circuits that:
% \begin{enumerate}
%    \item have polynomially-many internal nodes w.r.t. $n$, the number of leaves.
%    \item have depth $\bigO(t(n))$.
% \end{enumerate}
% Let $\complexityi{NC_{/poly}}{i} = \complexity{NC[(\log n)^i]_{/poly}}$. We define
% $\complexity{AC[t(n)]_{/poly}}, \complexity{TC[t(n)]_{/poly}}, \complexityi{AC_{/poly}}{i}, \complexityi{TC_{/poly}}{i}$ analogously.

% In particular, $\complexityi{NC_{/poly}}{0}$, $\complexityi{AC_{/poly}}{0}$, $\complexityi{TC_{/poly}}{0}$ are families of circuits with
% uniformly constant depth.

% For now we have not talked about how do we generate the consecutive circuits $C_n$.
% Later in~\autoref{sec:uniformity} we will restrict the family of (some standard) descriptions of the circuits
% to have to be \emph{computable efficiently} and then we will be able to drop the $_{/poly}$ suffix in our complexity classes.
% \end{definition}



% \section{\texorpdfstring{$\complexityi{NC}{i}_{/poly}$}{NC\string^ipoly}}

% \subsection{\complexityi{NC}{0}}
% For example, each output of an \complexityi{NC}{0} computable function can depend on only finitely many
% inputs. Thus, \complexityi{NC}{0} can't even compute an AND of all its inputs (in contrast, the unbounded
% fan-in AND is an \complexityi{AC}{0} function).
% \paragraph{TODO: Notes on $\complexityi{NC}{0}$.}
% TODO: Provide an introductory overview of the key references on $\complexityi{NC}{0}$ listed below.
% \begin{itemize}
% \item TODO: Summarize the construction of one-way permutations in $\complexityi{NC}{0}$~\cite{10.1016/0020-01908790053-6}.
% \item TODO: Explain why all sets complete under $\complexityi{AC}{0}$ reductions are already complete under $\complexityi{NC}{0}$ reductions~\cite{10.1145/258533.258671,AGRAWAL1998127}.
% \item TODO: Describe Immerman's page~81 discussion of addition in $\complexityi{NC}{0}$ and MAJORITY in $\complexityi{NC}{1}$~\cite{Immerman1999-IMMDC}.
% \item TODO: Detail why addition and subtraction of binary numbers lies in $\complexityi{AC}{0}$~\cite{27676}.
% \end{itemize}


% TODO: Clarify what notion of uniformity should be used for $\complexityi{NC}{0}$, given that \complexity{DLOGTIME} Turing machines can do things that cannot be done by
% any $\complexityi{NC}{0}$ circuit.
% \subsection{\complexityi{NC}{1}}
% \begin{itemize}
% \item TODO: Present the argument that division is in \complexity{DLOGTIME}-uniform $\complexityi{NC}{1}$~\cite{ITA_2001__35_3_259_0}.
% \item TODO: use \complexity{DLOGTIME} reductions for $\complexityi{NC}{1}$.
% \item TODO: Clarify how $U_{E^*}$ reductions relate to $\complexityi{NC}{1}$ and why $U_{E^*}$-uniform $\complexityi{NC}{1}$ equals \complexity{ALOGTIME}~\cite{RUZZO1981365}.
% \end{itemize}
% TODO: Confirm that this class is contained in $\complexityi{AC}{i}$.


% \section{\texorpdfstring{$\complexityi{AC}{i}$}{AC\string^i}}

% $\complexityi{AC}{i}$ is the class of languages accepted by uniform circuit
% families of polynomial size and depth $\bigO(\log^i n)$, consisting of unbounded fan-in
% AND, and OR gates, along with NOT gates.

% Given $x, y, z$: binary representations of natural numbers,
% it is decidable in uniform \complexityi{AC}{0} if $x + y = z$, but it is not decidable 
% in \complexityi{AC}{0} if $x * y = z$.

% \subsection{\complexityi{AC}{0}}
% \begin{itemize}
% \item TODO: Summarize why addition is in $\complexityi{AC}{0}$~\cite{BussLectureNotes}.
% \item TODO: Explain the equivalence $\text{FO}[+, *] = \complexity{DLOGTIME}$-uniform $\complexityi{AC}{0}$ (see \url{https://complexityzoo.net/Complexity_Zoo:A#ac0}).
% \item TODO: Discuss the characterization of \complexity{DLOGTIME}-uniform $\complexityi{AC}{0}$ presented in~\cite{hella2023regularrepresentationsuniformtc0}.
% \item TODO: Review the definitions of $\complexityi{AC}{0}$, $\complexityi{TC}{0}$, FATC0, and FTC0 provided in~\cite{612309}.
% \end{itemize}
% TODO: Document the notions of uniformity of $\complexityi{AC}{0}$ outlined below.
% \begin{enumerate}
% \item TODO: $U_{E^*}$-uniformity.
% \item TODO: uniform iff direct/extended connection language decidable by FO 
% \item TODO: uniform iff decidable by \complexity{DLOGTIME} random-access tm (checking whether the $i$th bit of the representation of the $n$th circuit is $b$).
% \end{enumerate}



% \section{\texorpdfstring{$\complexityi{AC}{i[m]}$}{AC\string^i[m]}}
% $\complexityi{AC}{i[m]}$ is defined as $\complexityi{AC}{i}$, but in addition unbounded fan-in $\text{MOD}_m$ gates
% are allowed, which output 1 iff the number of input wires carrying a value of 1 is a
% multiple of $m$.

% \section{\texorpdfstring{$\complexityi{ACC}{i}$}{\complexity{ACC}\string^i}}
% $\complexityi{ACC}{i} = \bigcup_m \complexityi{AC}{i[m]}$. $\complexityi{ACC}{0}$ is contained in $\complexityi{TC}{0}$.

% \section{\texorpdfstring{$\complexityi{TC}{i}$}{TC\string^i}}
% $\complexityi{TC}{i}$ is the class of languages accepted by uniform circuit families 
% of polynomial size and depth $\bigO(\log^i n)$, consisting of unbounded fan-in MAJORITY
% gates, along with NOT gates.

% TODO: Check whether $\complexityi{TC}{i}$ is contained in $\complexityi{NC}{i + 1}$.
% \subsection{\complexityi{TC}{0}}
% \begin{itemize}
% \item TODO: Confirm that multiplication is in $\complexityi{TC}{0}$~\cite{BussLectureNotes}, and locate the supporting details in~\cite{doi:10.1137/0213028}.
% \end{itemize}



% \section{Functional complexity classes}
% \label{sec:functional-complexity-classes}
% When we hear a sentence like ``prime factorization is in \complexity{NP}'', it usually
% means that the \emph{decisional} version of this problem is decidable in \complexity{NP}.

% But we actually usually want to reason about complexity of \emph{functions},
% and it appears to not be equivalent. E.g. \ the graph of exponential function is 
% decidable in polytime, but calculating exponential function is not.

% There is surprisingly little literature on functional complexity classes.
% An interesting case is \complexity{TFNP}, studied later in~\autoref{sec:complexity-class-tfnp}.
% Another interesting case are \emph{transductors}.

% \section{Uniformity}
% TODO: Clarify how \complexity{DLOGTIME}-uniformity, first-order reductions, logspace-uniformity, and $U_{E^*}$ relate, including the role of direct and extended connection languages.
% TODO: Provide a citation supporting that the choice among these uniformity notions does not affect the arguments below.
% When we do not say ``poly'', it means the class is uniform. Otherwise: Immerman showed that the class FO is the same as a uniform version
% of $\complexityi{AC}{0}$. Originally $\complexityi{AC}{0}$ was defined in its nonuniform version, which
% we shall refer to as $\complexityi{AC}{0}/\text{poly}$. A language in $\complexityi{AC}{0}/\text{poly}$ is specified by
% a polynomial size bounded depth family $\langle C_n \rangle$ of Boolean circuits, where
% each circuit $C_n$ has $n$ input bits, and is allowed to have $\neg$-gates, as well as
% unbounded fan-in $\land$-gates and $\lor$-gates. In the uniform version, the circuit
% $C_n$ must be specified in a uniform way; for example one could require that
% $\langle C_n \rangle$ is in FO\@. See also Appendix~A.5.

% We say that a family of circuits in $\complexityi{AC}{0}$ is uniform if the function $n \rightarrow C_n$ is
% \emph{simple to compute}; there is a variety of notions of uniformity of $\complexityi{AC}{0}$ circuits.
% TODO: Explore these notions in Chapter~\autoref{chap:reductions}. For the sake of this section we can assume
% that by $\complexityi{AC}{0}$ we denote the class of circuit families $C_n$, for which there is a 
% \complexity{LOGSPACE} Turing machine $M$ which on input $0^n$ outputs a \emph{standard representation}




% \section{\complexity{NP}}
% TODO: Clarify that the reductions used here are precisely the class \complexity{FL} of logspace reductions.

% \section{\complexity{FNP}}
% \begin{itemize}
% \item TODO: Extract the key points from the discussion at \url{https://cs.stackexchange.com/questions/71617/function-problems-and-fp-subseteq-fnp}.
% \item TODO: Summarize the insights from \url{https://cstheory.stackexchange.com/questions/37812/what-exactly-are-the-classes-fp-fnp-and-tfnp}.
% \item TODO: Cross-reference the definitions on \url{https://complexityzoo.net/Complexity_Zoo:F#fp}.
% \end{itemize}


% \section{\complexity{TFNP}}
% \label{sec:complexity-class-tfnp}

% \section{\texorpdfstring{$\complexityi{AC}{0}$-reduction}{AC\string^0-reduction}}
% \label{sec:ac0red}
% Definition IX.1.1 CN10. We say that a string function F
% (resp. \  a number function f) is $\complexityi{AC}{0}$-reducible to $L$ if there is a sequence
% of string functions $F_1, \dots, F_n (n \geqslant 0)$ such that
% $F_i$ is $\Sigma^B_0$-definable from $L \cup \{F_1, \dots , F_{i-1}\}$, for $i = 1, \dots, n$
% and F (resp. \ f) is $\Sigma^B_0$-definable from $L \cup \{F_1, \dots , F_{i-1}\}$. A relation R is
% $\complexityi{AC}{0}$-reducible to $L$ if there is a sequence $F_1, \dots, F_n$ as above, and R is
% represented by a $\Sigma^B_0(L \cup \{F_1, \dots, F_n\})$ formula.

% In Chapter~2 of~\cite{edbd4873718c414f90d22dadf0dba2b1} there is an extensive discussion about
% the different subtleties of defining $\complexityi{AC}{0}$ functions and numerous different characterizations
% of Dlogtime-uniform $\complexityi{AC}{0}$-computable functions.

% first-order/$\complexityi{AC}{0}$ are used for P-completeness.


% \section{\texorpdfstring{$\complexityi{NC}{0}$}{NC\string^0}} reductions
% In~\cite{edbd4873718c414f90d22dadf0dba2b1}, it is shown that, surprisingly, all known \complexity{NP}-complete problems
% are complete under $\complexityi{NC}{0/poly}$ reductions already. Another candidate for a problem that is \complexity{NP}-complete
% under poly-time reductions but not under logspace reductions is discussed in~\cite{18631}.


% \section{First-order reduction}
% TODO: Provide the definition of first-order reductions (see Chapter~12.3 of \url{https://link.springer.com/book/10.1007/3-540-28788-4}).

% \section{FO}
% \begin{itemize}
% \item TODO: Document why $\text{FO}[+, *] = \text{FO}[\mathrm{BIT}]$.
% \item TODO: Examine the status of the Crane Beach Conjecture asserting $\text{FO}[<, *] = \text{FO}[\mathrm{BIT}]$.
% \item TODO: Explain why $\text{FO}[+]$ is less expressive than $\text{FO}[<, *] = \text{FO}[<, /] = \text{FO}[<, \mathrm{COPRIME}]$~\cite{10.1002/malq.200310041}.
% \item TODO: Review the definition of FO-queries (Definition~1.26 in~\cite{Immerman1999-IMMDC}).
% \end{itemize}
% TODO: Describe FO-uniformity via first-order queries $I : \mathrm{STRUC}[ts] \rightarrow \mathrm{STRUC}[tc]$ with $I(0^n) = C_n$ (Definition~5.16 in~\cite{Immerman1999-IMMDC}).
% TODO: Restate that FO-reductions are defined as first-order queries (Definition~1.26 in~\cite{Immerman1999-IMMDC}).
% TODO: Include the definition explaining how to represent a circuit.

% \section{First-order projection}
% TODO: Note that first-order projections (FOPs) are also named in~\cite{Immerman1999-IMMDC}.
% TODO: Provide Definition~11.7 describing first-order projections.
% \section{Quantifier-free fo-projections}
% TODO: Summarize quantifier-free FO-projections (QFPs).

% \section{\complexity{LOGSPACE} reduction}
% \begin{itemize}
% \item TODO: reductions for \complexity{L}: first-order reductions (see~\cite[Section~5.1]{Immerman1999-IMMDC}).
% \item TODO: Revisit why USTCONN is complete for \complexity{L}.
% \item TODO: Example programming language characterizing \complexity{L}: finite number of variables each bounded by $n$.
% \item TODO: Explore the alternative characterization using a finite number of input pointers, relating it to multi-head two-way automata~\cite{423885},~\cite{10.1007/BF00289513}.
% \end{itemize}

% \section{\complexity{P} reduction}
% TODO: Outline the notion of \complexity{P}-reductions to be used later in this chapter.

% \section{Complete problems}
% \label{sec:complete-problems}
% TODO: (this is Cook, Nguyen somewher) Verify that for every class $C \in \{\complexityi{AC}{0}, \complexity{L}, \complexity{P}\}$ there exists a problem $F$ that is $C$-complete under $\complexityi{AC}{0}$ reductions.
% TODO: This means $\complexityi{AC}{0}$ reductions coincide with the class of $\complexityi{FAC}{0}$ functions.


% \subsection{Functional complexity classes and completeness}
% TODO: Determine whether showing $\complexity{L}$-completeness suffices for $\complexity{FL}$-completeness, using the identity $\complexity{FL} = \complexityi{L}{*} = \complexity{L} + \complexityi{NC}{1}$ reductions~\cite[Proposition~4.1]{COOK19852}.

% \section{Which class we will focus on?}
% \label{sec:classes-of-interest}
% For chapters about ICC we will focus on \complexity{L} and \complexity{P}, as these are the most abundant reductions,
% and other classes might have problems like in the below subsections.
% Later, in the chapter about bounded arithmetic we will find that we actually want to care
% about characterization of $\complexityi{AC}{0}$-reductions.


% \subsection{Semantic and syntactic complexity classes}
% TODO: Investigate which classes can realistically be characterized, likely excluding \complexity{BPP} and permutation-invariant \complexity{PTIME} (see \url{https://mathoverflow.net/questions/35236/is-there-a-syntactic-characterization-for-bpp-bqp-or-qma}).
% \begin{itemize}

% \item TODO: Extract key questions and scenarios from Anuj Dawar's ``On Syntactic and Semantic Complexity Classes'' (Spitalfields Day, Isaac Newton Institute, 9 January 2012), including the ``Two Possible Worlds'' discussion (\url{http://web.archive.org/web/20250428195619/https://www.frontiersinai.com/turingfiles/January/Dawar,%20A.pdf}).

% % ## Classes (conjectured) impossible to be captured syntactically
% % Some of the studied complexity classes remain notoriously difficult to be characterized implicitly. 
% % The classes for which a characterization exists are called 'syntactic' complexity classes, as opposed to 'semantic'
% % complexity classes, for which such characterization is conjectured to not exist.

% % - BPP  
% %     a characterization of which was however studied in [@lago2012higherordercharacterizationprobabilisticpolynomial].
% %     Despite that, PP has been characterized implicitly by Dal Lago in 2021: $\text{PP}$ [@dallago_et_al:LIPIcs.MFCS.2021.35].

% % - permutation-invariant PTIME
% %     The class `inv-P` of graph permutation-invariant problems decidable in polynomial time, is conjectured
% %     to not be characterizable this way. This is a restatement of the problem of finding a "logic capturing PTIME on unordered structures".
% %     A good discussion of this problem is present in Anuj Dawar's presentation from 2012: [@dawar2012syntactic].


% \end{itemize}

% \subsection{Related works on specifically the \complexity{FL} class}
% Early function algebras for \complexity{FL} appeared in~\cite{10.1145/1008293.1008295} and~\cite{lind1974logspace},
% but these were explicit characterizations.
% In~\cite{10.1007/BF01201998} it was shown how to readily use their concept
% to characterize functions from \complexity{FL} with ``small output'', but this characterization
% relied on using unary representation of natural numbers on input, which is more of a 
% hack than a true characterization of this class.
% In~\cite{murawski2000can}, with further refinements in~\cite{MURAWSKI2004197},
% \(BC^{-}\) was introduced, an algebra that was contained in \complexity{FL},
% but was not known (and unlikely) to be \complexity{FL}-complete.
% In~\cite{Neergaard04} this was improved to the result that \(BC_\varepsilon^{-} = \complexity{FL}\),
% with a short discussion that using course-of-value affine recursion instead of predicative affine recursion
% seem to be the reason behind \(BC_\varepsilon^{-}\) being FL-complete, and \(BC^{-}\) being probably not.

% In~\cite{4276584}, Stratified Bounded Affine Logic is introduced to capture \complexity{FL} computation.
% In~\cite{10.1007/978-3-662-46678-0_27}, an interesting approach using coinduction is utilized to capture \complexity{FL}.

% In~\cite{hofmann2006logspace} a good overview of languages for \complexity{FL} is presented,
% and in~\cite{schoepp2006spaceefficiency}, the history of \complexity{FL} characterizations is traced.
