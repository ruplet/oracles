\chapter[Propositions as types]{Propositions as types, proofs as programs: the Curry--Howard correspondence}
\label{chap:curry-howard}

The aim of this thesis is to reason about computation and its cost on standard machines. To do so, we will fix a minimal logical and computational core that is sufficient to state and track the shape of computations without introducing additional connectives or control features. In this chapter we present the implicational fragment of intuitionistic logic and the simply typed lambda calculus with only function types. We use these and nothing more.

\section{Computation and stepwise transformation}
A computation proceeds by a sequence of discrete steps that transform state. On a Turing machine, this discreteness is explicit in the transition function; on conventional hardware it is enforced by the processor clock; in functional languages it is captured by stepwise term rewriting. Counting such steps yields a cost measure employed later in the thesis. No additional effects or control features are used in this chapter.



\section{Implicational propositional calculus}
\label{sec:ipc}

\paragraph{Language.}
Fix a countable set $\mathcal{P}=\{P,Q,R,\dots\}$ of propositional variables (atomic formulas). Formulas are generated by
\[
A ::= \bot \mid P \mid (A \to A) \qquad (P \in \mathcal{P}).
\]
Negation is an abbreviation $\neg A := A \to \bot$.

\paragraph{Hilbert-style calculus.}
A derivation is a finite sequence of formulas. The system consists of the following axiom schemata and the single inference rule \emph{modus ponens}:
\[
\begin{array}{ll}
\text{(I1)} & A \to (B \to A), \\[2pt]
\text{(I2)} & \bigl(A \to (B \to C)\bigr) \to \bigl((A \to B) \to (A \to C)\bigr), \\[2pt]
\text{(EFQ)} & \bot \to A, \\[6pt]
\multicolumn{2}{l}{\infer[\mathrm{MP}]{B}{A \to B \quad A}.}
\end{array}
\]

\paragraph{Derivability.}
Let $\Gamma$ be a finite set (or list) of formulas. A formula $C$ is \emph{derivable from $\Gamma$}, written $\Gamma \vdash C$, if there exists a finite sequence $A_1,\dots,A_n$ with $A_n=C$ and, for each $i\le n$, one of the following holds: (i) $A_i$ is an instance of (I1), (I2), or (EFQ); (ii) $A_i \in \Gamma$; (iii) there exist $j,k<i$ and a formula $D$ with $A_j = D \to A_i$ and $A_k = D$ (an application of MP). A \emph{theorem} is a formula $C$ such that $\vdash C$.





\section{Simply typed lambda calculus}
\label{sec:stlc}

\paragraph{Atomic types.}
Fix a countable set $\mathcal{T}_0=\{\alpha,\beta,\gamma,\dots\}$ of base types (atomic types).

\paragraph{Types and terms.}
Types are generated by
\[
\tau ::= \bot \mid \alpha \mid (\tau \to \tau) \qquad (\alpha \in \mathcal{T}_0).
\]
Terms are
\[
t ::= x \mid \lambda x{:}\tau.\, t \mid (t\,u) \mid \mathsf{abort}_{\tau}(t).
\]
Here $\mathsf{abort}_{\tau}(t)$ is the eliminator for the empty type $\bot$.

\paragraph{Typing.}
Typing judgments have the form $\Gamma \vdash t : \tau$, where $\Gamma$ maps variables to types. The rules are:
\[
\infer{\Gamma, x{:}\tau \vdash x : \tau}{}
\qquad
\infer{\Gamma \vdash \lambda x{:}\tau.\, t : \tau \to \sigma}{\Gamma, x{:}\tau \vdash t : \sigma}
\qquad
\infer{\Gamma \vdash t\,u : \sigma}{\Gamma \vdash t : \tau \to \sigma \quad \Gamma \vdash u : \tau}
\]
\[
\infer{\Gamma \vdash \mathsf{abort}_{\tau}(t) : \tau}{\Gamma \vdash t : \bot}
\]

\paragraph{Evaluation.}
Evaluation is by $\beta$-reduction, closed under the usual congruence rules:
\[
(\lambda x{:}\tau.\, t)\,u \;\to_\beta\; t[x:=u].
\]
There is no reduction rule for $\mathsf{abort}_{\tau}$.







\section{Curry--Howard (implicational-only)}
Under the correspondence:
\[
\begin{aligned}
\text{propositions} &\;\leftrightarrow\; \text{types}, \\
\text{proofs} &\;\leftrightarrow\; \text{well-typed terms}, \\
\text{modus ponens / normalization} &\;\leftrightarrow\; \text{application / $\beta$-reduction}.
\end{aligned}
\]
Concretely:
\begin{itemize}
  \item A derivation of $\Gamma \vdash A \to B$ corresponds to a term $\lambda x{:}A.\,t$ with $\Gamma, x{:}A \vdash t : B$.
  \item A derivation using $\to$-elimination corresponds to application $t\,u$.
\end{itemize}
We will rely only on this fragment.

\section{Minimal running example}
We use the tautology
\[
A \to (B \to A),
\]
which reads: given a value of type $A$, and given a value of type $B$, we can return the original $A$.

\subsection*{Logical proof (natural deduction)}
TODO: IS THIS CORRECT? IT LOOOKS LIKE DEDUCTION THEOREM AND NOT IMPLICATION INTRODUCTION
\[
\infer[\to\mathrm{I}]{\vdash A \to (B \to A)}{
  \infer[\to\mathrm{I}]{A \vdash B \to A}{
    \infer[\mathrm{Ax}]{A, B \vdash A}{}
  }
}
\]
Reading this bottom-up: assume $A$; under that assumption, assume $B$; by the assumption $A$ we conclude $A$; discharge the $B$-assumption to obtain $B \to A$; discharge the $A$-assumption to obtain $A \to (B \to A)$.

\subsection*{Program (simply typed lambda calculus) and executable instance}
The corresponding term is the ``K'' combinator:
\[
\lambda a{:}A.\,\lambda b{:}B.\, a \;:\; A \to (B \to A).
\]
To run it on a computer, instantiate the atomic types with concrete ones. For example, take $A = \mathsf{int}$ and $B = \mathsf{bool}$ in OCaml:

\begin{verbatim}
(* k : int -> bool -> int *)
let k (a : int) (_b : bool) = a

let () =
  let r1 = k 42 true in
  let r2 = k 7 false in
  Printf.printf "%d %d\n" r1 r2
\end{verbatim}

This program is a direct executable instance of the proof. The application
\[
(\lambda a.\,\lambda b.\,a)\ 42\ \mathsf{true} \;\to_\beta\; (\lambda b.\,42)\ \mathsf{true} \;\to_\beta\; 42.
\]
No other features are used.

\section{Summary}
We fixed the implicational fragment of intuitionistic logic and the simply typed lambda calculus with only function types. Curry--Howard in this fragment identifies proofs with typed lambda terms and proof normalization with $\beta$-reduction. The single example $A \to (B \to A)$ illustrates both sides and compiles to an ordinary program without introducing any additional connectives or control constructs.
