\chapter{Clean code}
intuicja: clean code: the cleanest program is such that it is provably correct in the weakest logic!
We try to catch and state  precisely what do we mean by a 'practical' languauge / 'clean' code. but it takes us months to state this: code is clean when it is easy to prove correct!
3. Whats it the simplest programming language in which you can write an interpreter for another language?
While these question is difficult to even state for programming languages, 
the counterpart of simplest language interpreter is: weakest theory capable of proving the parser etc. correct!
Another line of research corresponded to breaking sterotypes about how programming languages have to be implemented. we examine the question: why is programming languages'
syntax modeled by a tree / represented with a CFG. we relate programming languages with
proof theories (tree-like vs dag-like proof systems + cirquent calculus i GoI). we analyze weakest representations, show st-connection(?) language to represent ac0 circuits in super simple reduction systems etc.

Co czyni jedne jezyk programowania lepszy od drugiego?
Co czyni kod czystszy od innego, dla tego samego problemu?
Krotszy dowod poprawnosci!
porownanie:
- kod w C vs wygenerowany ASM
- kod, ktory dla kazdej z 256 mozliwych wartosci chara zwraca wynik funkcji vs ktory oblicza








\section WHEN CAN A FEATURE BE ADDED

## Can a feature be safely added?  
Preserving semantic properties - such as guaranteed termination - while extending a language is often subtle and error-prone. This is particularly true in type systems, where even minor changes may lead to unsoundness, causing the type checker to validate ill-typed programs.  
In the setting of this thesis, the guiding question becomes: if we add a new feature as a primitive, will it still be the case that every program expresses a LOGSPACE algorithm?
While these questions are both deep and interesting, they fell outside the scope of this thesis and have not been considered further.



\section STRENGH OF METATHEORY

pytanie: czy jedynym typem w jezyku programowania moze byc int?
to by otwieralo droge do po prostu primitive recursion,
hierarchii grzegorczyka i latwej skladni
NIE MOZE BYC! bo nie mozemy.... UDOWODNIC poprawnosci!

Pytanie: co jest tak fundamentalnego w 'abstract syntax TREE?' czy syntax to drzewo?
a moze dag, albo jakis graf?
- Digression: why do we assume that proofs have a tree structure?
> Cirquent calculus is a proof calculus that manipulates graph-style constructs termed cirquents, as opposed to the traditional tree-style objects such as formulas or sequents.
Odpowiedz: caly reserach zamyka sie w dag-like vs tree-like proofs etc.

jak silna jest potrzebna logika by stwierdzić spójność / sprzeczność zestawu aksjomatów?
czy syntax musi być drzewem?
teoria typów metajęzyka
najsłabszy syntax, który wyrazi wszystkie poprawne programy innego języka
taki syntax jest w stanie rozwiązać problem HALT dla rozważanego języka!!
szukamy takiego metajęzyka, żeby problem stopu podjęzyka był łatwy.

# Implementing the interpreter 
- first problem: do our syntax really describe a tree?
- why does all of logic and proof theory look like just talking about trees?
- why is every proof a tree
- maybe not every? recent progress: Geometry of Interaction
- In proof theory, the Geometry of Interaction (GoI) was introduced by Jean-Yves Girard shortly after his work on linear logic. In linear logic, proofs can be seen as various kinds of networks as opposed to the flat tree structures of sequent calculus.
- so can syntax not be a tree?
- hint: first-order logic is compositional. does that mean that fundamentally
  it's theorems are described by a tree?

# Relation between the language and the metalanguage {.allowframebreaks}
- this is something which I don't understand
- how strong should be the metalanguage to ,,interpret'' the language considered?
- if the syntax of the language is naturally represented by a tree, we might need
  to have a tree type in the metalanguage
- strength of the type system of the metalanguage is tightly connected with
  our chosen representation of data structures used in the language
- e.g. if the language considered operates on graphs, we can pass the graph
  as an adjacency matrix, adjacency list or even a circuit which inputs a 
  node number encoded in binary and outputs its neighbors numbers as a bitmask
- what's the relation between automatas on trees to automatas on flat representations of trees (such as normal automata)
- what's the internal ,,difficulty'' of a programming language, e.g. what is the
  simplest description of computational processes modeled by the programming languages
  and the simplest interpreter, which can take this description and execute the process?

ANSWER: best syntax is such that correctness of its parsing can be proven in 
the weakest logic / weakest arithmetic!


file:///home/maryjane/Downloads/1235421934.pdf
strona 52 pdf, strona 316 ksiazki
chapter V Bounded arithmetic
tu jest o kodowaniu CFG


TUTAJ ZAMIESCIC PYTANIE Z MATHOVERFLOW


\section WEAKEST REPRESENTATIONS; WEAKEST INTERPRETER


Is AST Needed  
Proof systems with fixed points:  
[https://arxiv.org/pdf/2302.14825](https://arxiv.org/pdf/2302.14825)





Dlaczego reprezentacja wejscia ma znaczenie:  
Boolean formula evaluation is only complete for \complexity{LOGSPACE} if input formulae are represented as graphs  
(e.g., by the list of all edges plus gate types). It was however shown in \[2\] that the problem is complete for  
\complexityi{NC}{1} under \complexityi{AC}{0}-reductions if input formulae are given by their natural string encoding.  
[https://arxiv.org/pdf/1212.6567](https://arxiv.org/pdf/1212.6567)

+ dlaczego reprezentacja ma znaczenie? bo jak to lista bitow, to struktura jest uporzadkowana. jak podajemy jakies pierdolone abstrakcyjne drzewo, to nie jest uporzadkowana i logika musi byc duzo mocniejsza zeby dalej rozwiazywac nasz problem\!


unary numbers
vs numbers in lambda calculus (exponential size????)
vs binary natural numbers (always one at beginning...)
vs binary strings

- what is the weakest representation of solvable Sudoku?

- Digression:
> conversion of MSO to NFA is non-elementary, but NFA to MSO is linear-time  
> what are the best data representations?  
> what about languages over the unary alphabet?  
> are there np-hard languages over the unary alphabet?  
> can the only data type in the language be {1^n: n in Nat}?  
> it seems natural that the data type for computers is { {0,1}^n: n in Nat},  
> but for set-theory based mathematics, it's Set = Empty | {Set},  
> where {} stands for... a set. So like a list, but with no order and no duplicates


NAJNOWSZY POMYSL:

1. Dlaczego powinniśmy rozważać słabe języki programowania? Bo mają lepsze własności. Mogą nam pozwolić na więcej automatyzacji.  
   1. Przykład: prosty kalkulator z dodawaniem, odejmowaniem, mnożeniem, dzieleniem. Łatwo sprawdzić czy pozwoli nam wykonać nasze obliczenia. Jeśli się to nam uda, to mamy gwarancję kiedy skończy obliczenia itp.  
   2. Przykład negatywny: silnik regex wyrażający NFA. nie mamy dobrej gwarancji ile zużyje zasobów\! może spowodować DDoS taki jak miał cloudflare  
   3. Przykład: język Haskell, który poprzez ograniczanie efektów ubocznych daje użytkownikowi “gwarancję” na to że program nie zrobi czegoś bardzo niespodziewanego  
   4. Mamy też theorems for free. Albo BCK?  
2.   
3. Chcemy napisać interpreter języka programowania.   
   1. W jakim najsłabszym języku możemy go napisać? To jest pytanie o to jaka “najładniejsza” (pod względem właściwości) teoria będzie w stanie zdefiniować funkcję wyrażającą interpreter, i do tego udowodnić jej poprawność względem specyfikacji i terminację  
4. Chcemy napisać funkcję GCD(x, y). W jakiej najsłabszej teorii możemy ją zdefiniować i udowodnić?  
   1. Bardzo ważne źródło: [https://projecteuclid.org/eBooks/perspectives-in-logic/Metamathematics-of-First-Order-Arithmetic/toc/pl/1235421926](https://projecteuclid.org/eBooks/perspectives-in-logic/Metamathematics-of-First-Order-Arithmetic/toc/pl/1235421926)   
   2. Również tutaj ważne: [https://link.springer.com/article/10.1007/BF01375521](https://link.springer.com/article/10.1007/BF01375521)  
   3. Albo w metalogice pokazujemy definicję w matematyce i realizujemy z niej program, albo dowodzimy poprawności danego programu\!