Hey\!

I apologize for taking so long to get back \- just after we had spoken, I stumbled across a book by Steven Cook and Phuong Nguyen \[1\] which answers the questions I had been trying to solve (and even pose) for the past two years\!

The main question of my Master’s thesis is: how complicated does a programming language have to be, and how to design it, so that we can implement a program X in it? What is the simplest programming language expressing precisely the functions from a complexity class C? Cook and Nguyen spent decades designing their theory in the area of bounded arithmetic (or bounded reverse mathematics) and I think it is detailed and practical enough to provide a basis for a new proof assistant (not based on type theory\!). They introduce logical theories VC, corresponding to complexity classes C, such that if a theorem is provable in VC, the induction hypotheses needed in the proof can be formulated using concepts from C. I believe this work is important, as it would probably enable us to formalize simple theorems (and concepts from daily programming practice\!) in a very straightforward way, not requiring any complicated tool such as Coq, HOL or Mizar\! There are also reasons to believe that code extraction from such a system would be feasible, as “Witnessing theorems” are proved in this book for some of their logics. But this aspect is logically subtle; the proofs as-is don’t seem to be computationally feasible ([https://mathoverflow.net/q/492469/561687](https://mathoverflow.net/q/492469/561687)) 

I spent some time trying to formalize their results in Isabelle/Pure and in Lean, but my lack of logical expertise really limits me. I spoke to a good couple of people in Warsaw trying to get their attention, but it’s really difficult for me to convince anyone that it makes sense to take on this project, as it requires some intuition on both logic and formal verification. If you would like to hear more about it and why I believe it is interesting and super impactful, please let me know and I will try to sell this idea to you :) Also, if you have the intuitions, or work with someone who has them, on the practicality of theorems in logic and reverse maths, please let me know \- I will be more than happy to consult what would be the best direction to formalize their results.

I have also come up with a few projects I think could be impactful in automated reasoning. These are alternatives to the ongoing projects in Prague we spoke about last time. I will be happy to help you with your projects, but am also curious if we could find some common ground on the ideas below:

1) In Prague, you hold the SAT Solving competition. I think this is really cool, as SAT solvers show that it is possible and practical to solve problems which don’t seem computationally feasible.   
   1) ‘tauto’ for weaker logics: I think it would be interesting to take a logic for which the problem of checking if a formula is a tautology is in NP, embed it in Coq or Lean and create tactic ‘weaktauto’, hammering this logic using a SAT solver, similarly to ‘tauto’ from Coq / ‘itauto’ from Lean, which solves more (is in PSPACE).  
   2) A demonstration of the power of these tactics (including ‘tauto’\!) would be to reduce e.g. Hamilton cycle problem to tautology problem in this logic, hammer the instance with the tactic (so, construct the intuitionistic proof or fail), and parse out the answer to Hamilton cycle from the proof. I have already implemented it partially, reducing Hamilton to IIPL tautology, running ‘itauto’ tactic and extracting the cycle from the actual proof created by ‘itauto’. But I wasn’t able to test it very thoroughly, as the ‘itauto’ stackoverflowed for n=3 (the formula had \~100 clauses for this size). For weaker logics (e.g. logic with tauto problem in NP), we could perhaps implement the tactic using a sat-solver.  
   3) ‘tauto’ tactics are not designed to handle large instances. I think it would be interesting to show how powerful these tactics are, and how Coq can be used as a strong calculator, by showing a reduction from Sokoban to IIPL tautology problem, hammering it with tauto and drawing graphically (as an animation\!) the Sokoban solution extracted from the intuitionistic proof. This would require us to have something stronger than a SAT-solver, perhaps a  QBNF solver. We can’t really do it readily, as ‘itauto’ quickly stackoverflows, and ‘tauto’ is slow.   