- This is cool: Polymorphism all the way up! From System F to the Calculus of Constructions
> https://xavierleroy.org/CdF/2018-2019/2.pdf

intuicja: clean code:
We try to catch and state  precisely what do we mean by a 'practical' languauge / 'clean' code. but it takes us months to state this: code is clean when it is easy to prove correct!
3. Whats it the simplest programming language in which you can write an interpreter for another language?
While these question is difficult to even state for programming languages, 
the counterpart of simplest language interpreter is: weakest theory capable of proving the parser etc. correct!
Another line of research corresponded to breaking sterotypes about how programming languages have to be implemented. we examine the question: why is programming languages'
syntax modeled by a tree / represented with a CFG. we relate programming languages with
proof theories (tree-like vs dag-like proof systems + cirquent calculus i GoI). we analyze weakest representations, show st-connection(?) language to represent ac0 circuits in super simple reduction systems etc.


In a paper from 2019, Jean-Yves Moyen and Jakob Grue Simonsen discuss the problem of providing syntax for PTIME ,
concluding that in the light of their generalization of Rice's theorem [@10.1007/978-3-030-22996-2_19]. (problem w reprezentacji:
mozemy miec jezyk programowania dla P, ale odkladamy nierozstrzygalnos do problemu sprawdzenia czy mozna przetlumaczyc dana maszyne turinga na ten jezyk)
@InProceedings{10.1007/978-3-030-22996-2_19,
author="Moyen, Jean-Yves
and Simonsen, Jakob Grue",
editor="Manea, Florin
and Martin, Barnaby
and Paulusma, Dani{\"e}l
and Primiero, Giuseppe",
title="More Intensional Versions of Rice's Theorem",
booktitle="Computing with Foresight and Industry",
year="2019",
publisher="Springer International Publishing",
address="Cham",
pages="217--229",
abstract="Classic results in computability theory concern extensional results: the behaviour of partial recursive functions rather than the programs computing them. We prove a generalisation of Rice's Theorem concerning equivalence classes of programs and show how it can be used to study intensional properties such as time and space complexity. While many results that follow from our general theorems can - and have - been proved by more involved, specialised methods, our results are sufficiently simple that little work is needed to apply them.",
isbn="978-3-030-22996-2"
}

### Proving unprovability: Kripke semantics
- even though searching for a countermodel in Kripke semantics is completely infeasible computationally, we have a good tool for the job!
- i tested and it works, find countermodels and proofs of intuitionistic formulas. code: https://github.com/ferram/jtabwb_provers/tree/master

### Proving unprovability: forcing
- Extending Type Theory with Forcing (INRIA, 2012)
> Implementation of forcing in Coq as a program transformation and show a proof of the negation of CH  
> https://hal.science/hal-00685150/document

- A beginnerâ€™s guide to forcing
> https://arxiv.org/pdf/0712.1320

- Forcing for dummies blogpost
> https://timothychow.net/mathstuff/forcingdum.txt

- Baker-Gill-Solovay theorem proof
> Forcing as a method to prove that something can or cannot be done using an oracle  
> https://cstheory.stackexchange.com/questions/14091/forcing-method-used-in-baker-gill-solovay-relativization-paper-and-cohens-proof  
> https://math.stackexchange.com/questions/2616541/simple-applications-of-forcing-in-recursion-theory  
> https://en.wikipedia.org/wiki/Forcing_(computability)

forcing zeby badac jezyki programowania: to jak oracles w computational complexity!
https://cstheory.stackexchange.com/a/14093
see here for oracle A such that NEXP^A = P^{NP^{A}}
what it means in logic when you have P^A,B vs P^A^B?
https://link.springer.com/article/10.1007/s00037-001-8190-2
